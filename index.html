<!DOCTYPE html>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
  
  <title>莫小白</title>
  <meta charset="UTF-8">
  <meta name="description" content="研究研究，随便写写">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png">
  <meta name="description" content="研究研究，随便写写">
<meta name="keywords" content="develop, share">
<meta property="og:type" content="website">
<meta property="og:title" content="莫小白">
<meta property="og:url" content="http://mercutio.club/index.html">
<meta property="og:site_name" content="莫小白">
<meta property="og:description" content="研究研究，随便写写">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="莫小白">
<meta name="twitter:description" content="研究研究，随便写写">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/css/mdui.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.15.8/styles/atom-one-dark.css">
   
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1038733_0xvrvpg9c0r.css">
  <link rel="stylesheet" href="/css/style.css?v=1574932694063">
</head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(/images/default_background.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">menu</i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="Mercutio" class="mdui-btn mdui-btn-icon"><img src="/images/avatar.png"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Mercutio">
            <img src="/images/avatar.png" alt="Mercutio">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>7</div>
        <div><span>标签</span>6</div>
        <div><span>分类</span>7</div>
    </div>
    <ul class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
    </ul>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/4325844/" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/mercutiojohn" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Algorithm/">Algorithm</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/CSS/">CSS</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/CSS/Flex/">Flex</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Hexo搭建/">Hexo搭建</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Linux/">Linux</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Termux/">Termux</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Algorithm/算法/">算法</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">标签云</h3>
    <div id="randomtagcloud" class="nexmoe-widget tagcloud">
      <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Hexo搭建/" style="font-size: 10px;">Hexo搭建</a> <a href="/tags/Termux/" style="font-size: 10px;">Termux</a> <a href="/tags/排序/" style="font-size: 10px;">排序</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a>
    </div>
    
  </div>

  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li></ul>
    </div>
  </div>


  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2019 Mercutio
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts" id="brand-waterfall">
    
    <div class="nexmoe-post">
        <a href="/2019/11/28/在个人博客里添加评论系统-Gitalk/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/default_background.jpg" alt="在个人博客里添加评论系统 Gitalk">
                
                <h1>在个人博客里添加评论系统 Gitalk</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年11月28日</a>
            <a><i class="nexmoefont icon-areachart"></i>454 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 2 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/Hexo搭建/">Hexo搭建</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/Git/">Git</a> <a class="nexmoefont icon-tag-fill -link" href="/tags/Hexo搭建/">Hexo搭建</a>
            
        </div>
        <article>
            
            <hr>
<p>前提是 <a href="ttps://weijunzii.github.io/2018/04/02/Use-github-Set-Up-The-Blog.html" target="_blank" rel="noopener">搭建了博客</a>，使用的主题是 <a href="https://github.com/kaeyleo/jekyll-theme-H2O/" target="_blank" rel="noopener">jekyll-theme-H2O</a> 这个主题。其余的可以借鉴，但不一定完全适用。</p>
<p>Gitalk 是一个评论系统，在个人博客里添加了之后就可以很简便的进行评论和回复了。</p>
<hr>
<p>首先要注册一下 GitHub Application，</p>
<blockquote>
<p><a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a></p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/2989110-4a0a03966f357a46.png" alt></p>
<p>注册完就会有 Client ID 和 Client Secret</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2989110-c856407bdf2877b9.png" alt></p>
<p>在 comments 那添加</p>
<pre><code>gitalk: true
  gitalk_clientID: &#39;Client ID&#39;
  gitalk_Secret: &#39;Client Secret&#39;
  gitalk_repo: &#39;用户名.github.io&#39;
  gitalk_owner: &#39;用户名&#39;
  gitalk_admin: &#39;用户名&#39;
  distractionFreeMode: true</code></pre><p>是在 comments 下面那添加，不要搞错地方。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2989110-c27643270bc9d4a0.png" alt></p>
<hr>
<p>文件的位置在 <code>_layouts\post.html</code></p>
<h2 id="3-0-在-lt-html-gt-这个标签下添加"><a href="#3-0-在-lt-html-gt-这个标签下添加" class="headerlink" title="3.0 在 &lt;html&gt; 这个标签下添加"></a>3.0 在 <code>&lt;html&gt;</code> 这个标签下添加</h2><p>在 <code>&lt;html&gt;</code> 这个标签下加上这两行</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>就像这样</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2989110-84c51b2a8c713798.png" alt></p>
<h2 id="3-1-在-include-footer-html-里添加"><a href="#3-1-在-include-footer-html-里添加" class="headerlink" title="3.1 在 % include footer.html % 里添加"></a>3.1 在 <code>% include footer.html %</code> 里添加</h2><pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>如图所示，位置不要搞错</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2989110-c10dd3d79b1efee4.png" alt></p>
<h2 id="3-2-在-if-site-comments-disqus-后面添加"><a href="#3-2-在-if-site-comments-disqus-后面添加" class="headerlink" title="3.2 在 % if site.comments.disqus % 后面添加"></a>3.2 在 <code>% if site.comments.disqus %</code> 后面添加</h2><pre><code>{% if site.comments.gitalk %}
    <script>
        var gitalk = new Gitalk({
              clientID: '{{ site.comments.gitalk_clientID }}',
              clientSecret: '{{ site.comments.gitalk_Secret }}',
              repo: '{{ site.comments.gitalk_repo }}',
              owner: '{{ site.comments.gitalk_owner }}',
              admin: '{{ site.comments.gitalk_admin }}',
              id: location.pathname,      // Ensure uniqueness and length less than 50{{ page.title }}
              distractionFreeMode: '{{ site.comments.distractionFreeMode }}'  // Facebook-like distraction free mode
            })

            gitalk.render('disqus_thread')
    </script>
  {% endif %}</code></pre><p>如图所示</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2989110-1aebbf1abb854ebb.png" alt></p>
<p>关于 <code>post.html</code> 这部分的修改可以看一下我的<a href="https://github.com/weijunzii/weijunzii.github.io/commit/0ba47d4b3b437d73f7079bb9efba181f172520d7" target="_blank" rel="noopener">修改</a></p>
<p>保存修改，再提交。</p>
<hr>
<p>进入博客，点击设置</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2989110-e4091c3257e87b3e.png" alt></p>
<p>进去后勾选一下 issues 就搞定了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2989110-dedec6f428555672.png" alt></p>
<p>再去看一下你博客里面的文章，如果说出现了评论框，那就是成功了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2989110-84fa2b8630072736.png" alt></p>
<hr>
<p>参考了这篇文章才实现的：<a href="https://tea9.github.io/2018/06/24/gitali_config.html" target="_blank" rel="noopener">https://tea9.github.io/2018/06/24/gitali_config.html</a></p>
<p>文章作者写的说明：<a href="http://note.youdao.com/publicshare/?id=6ea132ba501b49b2928125a694cc9ad9#/" target="_blank" rel="noopener">http://note.youdao.com/publicshare/?id=6ea132ba501b49b2928125a694cc9ad9#/</a></p>
<p>使用的主题是：<a href="https://github.com/kaeyleo/jekyll-theme-H2O/" target="_blank" rel="noopener">jekyll-theme-H2O</a></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2019/11/28/Flex 布局语法/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                <img src="https://www.runoob.com/wp-content/uploads/2015/07/5a7d00514af1e464221c677c15e8e990.png" alt="Flex布局语法">
                
                <h1>Flex布局语法</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年11月28日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.7k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 7 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/CSS/">CSS</a><a class="nexmoefont icon-appstore-fill -link" href="/categories/CSS/Flex/">Flex</a>
            
            
        </div>
        <article>
            
            <p>网页布局（layout）是 CSS 的一个重点应用。</p>
<!-- ![](https://www.runoob.com/wp-content/uploads/2015/07/7bf8bed24a17fbebd3e171f9630dbccb.gif) -->

<p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model" target="_blank" rel="noopener">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display" target="_blank" rel="noopener">display</a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="noopener">position</a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="noopener">float</a> 属性。它对于那些特殊布局非常不方便，比如，<a href="https://css-tricks.com/centering-css-complete-guide/" target="_blank" rel="noopener">垂直居中</a>就不容易实现。</p>
<!-- ![](https://www.runoob.com/wp-content/uploads/2015/07/5a7d00514af1e464221c677c15e8e990.png) -->

<p>2009 年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/07/8712d713c7d0b884a5cb9770efc422b4.jpg" alt></p>
<p>Flex 布局将成为未来布局的首选方案。本文介绍 Flex 布局的语法。</p>
<p>以下内容主要参考了下面两篇文章：<a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">A Complete Guide to Flexbox</a> 和 <a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties" target="_blank" rel="noopener">A Visual Guide to CSS3 Flexbox Properties</a>。</p>
<h2 id="一、Flex-布局是什么？"><a href="#一、Flex-布局是什么？" class="headerlink" title="一、Flex 布局是什么？"></a>一、Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为” 弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<p>任何一个容器都可以指定为 Flex 布局。</p>
<pre><code>.box{
  display: flex;
}</code></pre><p>行内元素也可以使用 Flex 布局。</p>
<pre><code>.box{
  display: inline-flex;
}</code></pre><p>Webkit 内核的浏览器，必须加上 - webkit 前缀。</p>
<pre><code>.box{
  display: -webkit-flex; /* Safari */
  display: flex;
}</code></pre><p>注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</p>
<h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称” 容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称” 项目”。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/07/3791e575c48b3698be6a94ae1dbff79d.png" alt></p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。</p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</p>
<h2 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h2><p>以下 6 个属性设置在容器上。</p>
<blockquote>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
</blockquote>
<h3 id="3-1-flex-direction-属性"><a href="#3-1-flex-direction-属性" class="headerlink" title="3.1 flex-direction 属性"></a>3.1 flex-direction 属性</h3><p>flex-direction 属性决定主轴的方向（即项目的排列方向）。</p>
<pre><code>.box {
  flex-direction: row | row-reverse | column | column-reverse;
}</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/0cbe5f8268121114e87d0546e53cda6e.png" alt></p>
<p>它可能有 4 个值。</p>
<blockquote>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
</blockquote>
<h3 id="3-2-flex-wrap-属性"><a href="#3-2-flex-wrap-属性" class="headerlink" title="3.2 flex-wrap 属性"></a>3.2 flex-wrap 属性</h3><p>默认情况下，项目都排在一条线（又称” 轴线”）上。flex-wrap 属性定义，如果一条轴线排不下，如何换行。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/07/903d5b7df55779c03f2687a7d4d6bcea.png" alt></p>
<pre><code>.box{
  flex-wrap: nowrap | wrap | wrap-reverse;
}</code></pre><p>它可能取三个值。</p>
<p>（1）nowrap（默认）：不换行。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/07/9da1f23965756568b4c6ea7124db7b9a.png" alt></p>
<p>（2）wrap：换行，第一行在上方。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/07/3c6b3c8b8fe5e26bca6fb57538cf72d9.jpg" alt></p>
<p>（3）wrap-reverse：换行，第一行在下方。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/07/fb4cf2bab8b6b744b64f6d7a99cd577c.jpg" alt></p>
<h3 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h3><p>flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。</p>
<pre><code>.box {
  flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;
}</code></pre><h3 id="3-4-justify-content-属性"><a href="#3-4-justify-content-属性" class="headerlink" title="3.4 justify-content 属性"></a>3.4 justify-content 属性</h3><p>justify-content 属性定义了项目在主轴上的对齐方式。</p>
<pre><code>.box {
  justify-content: flex-start | flex-end | center | space-between | space-around;
}</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/c55dfe8e3422458b50e985552ef13ba5.png" alt></p>
<p>它可能取 5 个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<blockquote>
<ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
</blockquote>
<h3 id="3-5-align-items-属性"><a href="#3-5-align-items-属性" class="headerlink" title="3.5 align-items 属性"></a>3.5 align-items 属性</h3><p>align-items 属性定义项目在交叉轴上如何对齐。</p>
<pre><code>.box {
  align-items: flex-start | flex-end | center | baseline | stretch;
}</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/2b0c39c7e7a80d5a784c8c2ca63cde17.png" alt></p>
<p>它可能取 5 个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<blockquote>
<ul>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。</li>
</ul>
</blockquote>
<h3 id="3-6-align-content-属性"><a href="#3-6-align-content-属性" class="headerlink" title="3.6 align-content 属性"></a>3.6 align-content 属性</h3><p>align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<pre><code>.box {
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/f10918ccb8a13247c9d47715a2bd2c33.png" alt></p>
<p>该属性可能取 6 个值。</p>
<blockquote>
<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个交叉轴。</li>
</ul>
</blockquote>
<h3 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h3><p>以下 6 个属性设置在项目上。</p>
<blockquote>
<ul>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flex</li>
<li>align-self</li>
</ul>
</blockquote>
<h3 id="4-1-order-属性"><a href="#4-1-order-属性" class="headerlink" title="4.1 order 属性"></a>4.1 order 属性</h3><p>order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p>
<pre><code>.item {
  order: &lt;integer&gt;;
}</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/59e399c72daafcfcc20ede36bf32f266.png" alt></p>
<h3 id="4-2-flex-grow-属性"><a href="#4-2-flex-grow-属性" class="headerlink" title="4.2 flex-grow 属性"></a>4.2 flex-grow 属性</h3><p>flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。</p>
<pre><code>.item {
  flex-grow: &lt;number&gt;; /* default 0 */
}</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/f41c08bb35962ed79e7686f735d6cd78.png" alt></p>
<p>如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p>
<h3 id="4-3-flex-shrink-属性"><a href="#4-3-flex-shrink-属性" class="headerlink" title="4.3 flex-shrink 属性"></a>4.3 flex-shrink 属性</h3><p>flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</p>
<pre><code>.item {
  flex-shrink: &lt;number&gt;; /* default 1 */
}</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/240d3e960043a729bb3ff5e34987904f.jpg" alt></p>
<p>如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。</p>
<p>负值对该属性无效。</p>
<h3 id="4-4-flex-basis-属性"><a href="#4-4-flex-basis-属性" class="headerlink" title="4.4 flex-basis 属性"></a>4.4 flex-basis 属性</h3><p>flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。</p>
<pre><code>.item {
  flex-basis: &lt;length&gt; | auto; /* default auto */
}</code></pre><p>它可以设为跟 width 或 height 属性一样的值（比如 350px），则项目将占据固定空间。</p>
<h3 id="4-5-flex-属性"><a href="#4-5-flex-属性" class="headerlink" title="4.5 flex 属性"></a>4.5 flex 属性</h3><p>flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。</p>
<pre><code>.item {
  flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]
}</code></pre><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h3 id="4-6-align-self-属性"><a href="#4-6-align-self-属性" class="headerlink" title="4.6 align-self 属性"></a>4.6 align-self 属性</h3><p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p>
<pre><code>.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2015/07/55b19171b8b6b9487d717bf2ecbba6de.png" alt></p>
<p>该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。</p>
<!-- > 来源：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html -->
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2019/11/28/在 liunx 上安装出错 没有 npm/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/default_background.jpg" alt="在liunx上安装出错 没有 npm">
                
                <h1>在liunx上安装出错 没有 npm</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年11月28日</a>
            <a><i class="nexmoefont icon-areachart"></i>445 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 2 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/Linux/">Linux</a>
            
            
        </div>
        <article>
            
            <p>我在 Windows 上安装了 Ubuntu Bash。我已经拥有 nodejs 并 npm 在我的 Windows 机器上了 C:\Program Files\nodejs。在 Windows 的 bash shell 中，我正在运行一个使用 npm install 命令的脚本。该脚本给出以下错误</p>
<dl><dt>: not foundram Files/nodejs/npm: 3: /mnt/c/Program Files/nodejs/npm:</dt><dd>not foundram Files/nodejs/npm: 5: /mnt/c/Program Files/nodejs/npm:<br>/mnt/c/Program Files/nodejs/npm: 6: /mnt/c/Program Files/nodejs/npm: Syntax error: word unexpected (expecting “in”)<br>NPM - 安装</dd></dl><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>“您也可以使用 Windows PowerShell 安装 node 和 npm，因此如果您这样做，它将无法正常运行您的子系统。这意味着您必须安装两次（Powershell 和 Subsystem）或者您决定做一件事。”</p>
<p>如果前面的文字，没有帮助你，这是如何解决问题：<br>删除当前的安装</p>
<pre><code>sudo apt-get --purge remove node
(&quot;sudo apt autoremove node&quot; if console is asking for)
sudo apt-get --purge remove nodejs</code></pre><p>以正确的方式安装节点</p>
<pre><code>curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -
sudo apt-get install -y nodejs
sudo apt install note</code></pre><p>然后安装构建工具，以便稍后为 npm 安装附加组件</p>
<pre><code>sudo apt-get install -y build-essential</code></pre><p>关于版本过低，修改下 setup_X.0 去修改<br>现在你可以输入</p>
<p>npm -v<br>node -v<br>Same thing: nodejs -v<br>检查 npm 是否安装正确。它应该是。</p>
<p>这是一个可以帮助您的链接。<br><a href="https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions" target="_blank" rel="noopener">https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions</a></p>
<p>注意：如果在完成此操作后显示相同的错误，请重新启动 bash。</p>
<p>补一点杂粮</p>
<blockquote>
<p>sudo apt-get install build-essential patch ruby-dev libmysqlclient-dev<br>sudo apt-get install ruby-mysql2 git ruby rails<br>sudo apt-get install vim<br>git clone <a href="http://10.206.142.24/dengt7/zxy.git" target="_blank" rel="noopener">http://10.206.142.24/dengt7/zxy.git</a><br>cd zxy<br>bundle install<br>sudo gem pristine –all<br>进入到项目目录之后 rails server<br>打开浏览器输 127.0.0.1:3000<br>看到冒烟测试页面则成功</p>
</blockquote>
<p>可能还有问题</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2019/11/19/Termux 高级终端初探/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/default_background.jpg" alt="Termux高级终端安装使用配置教程">
                
                <h1>Termux高级终端安装使用配置教程</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年11月19日</a>
            <a><i class="nexmoefont icon-areachart"></i>7.4k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 32 分钟</a>
            
            
        </div>
        <article>
            
            <!-- 原文地址 https://www.sqlsec.com/2018/05/termux.html#toc-heading-9 -->

<p><img src="https://image.3001.net/images/20180501/15251875958364.png" alt></p>
<p>Termux 高级终端安装使用配置教程, 这篇文章拖了有小半年. 因为网上相关的文章相对来说还是比较少的, 恰好今天又刷了机, 所以就特意来总结一下, 希望本文可以帮助到其他的小伙伴. 发挥 Android 平台更大的 DIY 空间.</p>
<p><code>Termux</code>是一个<code>Android</code>下一个高级的终端模拟器, 开源且不需要<code>root</code>, 支持<code>apt</code>管理软件包，十分方便安装软件包, 完美支持<code>Python</code>,<code>PHP</code>,<code>Ruby</code>,<code>Go</code>,<code>Nodejs</code>,<code>MySQL</code>等。随着智能设备的普及和性能的不断提升，如今的手机、平板等的硬件标准已达到了初级桌面计算机的硬件标准, 用心去打造完全可以把手机变成一个强大的工具.</p>
<ul>
<li><a href="https://termux.com/" target="_blank" rel="noopener">官网</a></li>
<li><a href="https://github.com/termux/termux-app" target="_blank" rel="noopener">Github 项目地址</a></li>
<li><a href="https://play.google.com/store/apps/details?id=com.termux" target="_blank" rel="noopener">Google Play 下载地址</a></li>
</ul>
<blockquote>
<p>Google Play 下载的版本比酷安要新, 有能力建议下载 Google PLay 版本的.</p>
</blockquote>
<h2 id="长按屏幕"><a href="#长按屏幕" class="headerlink" title="长按屏幕"></a><a href="#长按屏幕" title="长按屏幕"></a>长按屏幕</h2><p>显示菜单项（包括复制、粘贴、更多），此时屏幕出现可选择的复制光标</p>
<p><img src="https://image.3001.net/images/20180501/15251424532278.png" alt></p>
<pre><code>长按屏幕
├── COPY:复制
├── PASTE:更多
├── More:更多
   ├── Select URL: 选择网址
   └── Share transcipt: 分享命令脚本
   └── Reset: 重置
   └── Kill process: 杀掉当前终端会话进程
   └── Style: 风格配色
   └── Help: 帮助文档</code></pre><h2 id="从左向右滑动"><a href="#从左向右滑动" class="headerlink" title="从左向右滑动"></a><a href="#从左向右滑动" title="从左向右滑动"></a>从左向右滑动</h2><p>显示隐藏式导航栏，可以新建、切换、重命名会话 session 和调用弹出输入法</p>
<p><img src="https://image.3001.net/images/20180501/15251425706184.png" alt></p>
<h2 id="显示扩展功能按键"><a href="#显示扩展功能按键" class="headerlink" title="显示扩展功能按键"></a><a href="#显示扩展功能按键" title="显示扩展功能按键"></a>显示扩展功能按键</h2><p>扩展功能键是什么? 就是 PC 端常用的按键如: ESC 键，CTR 键，TAB 键, 但是手机上难以操作的一些按键.</p>
<p><strong>效果图</strong></p>
<p><img src="https://image.3001.net/images/20180501/15251430134084.png" alt></p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a><a href="#方法一" title="方法一"></a>方法一</h3><p>从左向右滑动, 显示隐藏式导航栏, 长按左下角的<code>KEYBOARD</code>.</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a><a href="#方法二" title="方法二"></a>方法二</h3><p>使用<code>Termux</code>快捷键:<code>音量+</code>+<code>Q</code>键</p>
<p><code>Ctrl</code>键是终端用户常用的按键 - 但大多数触摸键盘都没有这个按键。为此，Termux 使用<code>音量减小按钮</code>来模拟<code>Ctrl</code>键。<br>例如，在触摸键盘上按<code>音量减小</code>+ <code>L</code>发送与在硬件键盘上按<code>Ctrl + L</code>相同的输入。</p>
<ul>
<li><code>Ctrl+A</code> -&gt; 将光标移动到行首</li>
<li><code>Ctrl+C</code> -&gt; 中止当前进程</li>
<li><code>Ctrl+D</code> -&gt; 注销终端会话</li>
<li><code>Ctrl+E</code> -&gt; 将光标移动到行尾</li>
<li><code>Ctrl+K</code> -&gt; 从光标删除到行尾</li>
<li><code>Ctrl+L</code> -&gt; 清除终端</li>
<li><code>Ctrl+Z</code> -&gt; 挂起（发送 SIGTSTP 到）当前进程</li>
</ul>
<p><code>音量加键</code>也可以作为产生特定输入的<code>特殊键</code>.</p>
<ul>
<li><code>音量加+E</code> -&gt; Esc 键</li>
<li><code>音量加+T</code> -&gt; Tab 键</li>
<li><code>音量加+1</code> -&gt; F1（和音量增加 + 2→F2 等）</li>
<li><code>音量加+0</code> -&gt; F10</li>
<li><code>音量加+B</code> -&gt; Alt + B，使用 readline 时返回一个单词</li>
<li><code>音量加+F</code> -&gt; Alt + F，使用 readline 时转发一个单词</li>
<li><code>音量加+X</code> -&gt; Alt+X</li>
<li><code>音量加+W</code> -&gt; 向上箭头键</li>
<li><code>音量加+A</code> -&gt; 向左箭头键</li>
<li><code>音量加+S</code> -&gt; 向下箭头键</li>
<li><code>音量加+D</code> -&gt; 向右箭头键</li>
<li><code>音量加+L</code> -&gt; | （管道字符）</li>
<li><code>音量加+H</code> -&gt; 〜（波浪号字符）</li>
<li><code>音量加+U</code> -&gt; _ (下划线字符)</li>
<li><code>音量加+P</code> -&gt; 上一页</li>
<li><code>音量加+N</code> -&gt; 下一页</li>
<li><code>音量加+.</code> -&gt; Ctrl + \（SIGQUIT）</li>
<li><code>音量加+V</code> -&gt; 显示音量控制</li>
<li><code>音量加+Q</code> -&gt; 显示额外的按键视图</li>
</ul>
<p><code>Termux</code>除了支持<code>apt</code>命令外, 还在此基础上封装了<code>pkg</code>命令,<code>pkg</code>命令向下兼容<code>apt</code>命令.<code>apt</code>命令大家应该都比较熟悉了, 这里直接简单的介绍下<code>pkg</code>命令:</p>
<p>Bash</p>
<pre><code>pkg search &lt;query&gt;              搜索包
pkg install &lt;package&gt;           安装包
pkg uninstall &lt;package&gt;         卸载包
pkg reinstall &lt;package&gt;         重新安装包
pkg update                      更新源
pkg upgrade                     升级软件包
pkg list-all                    列出可供安装的所有包
pkg list-installed              列出已经安装的包
pkg shoe &lt;package&gt;              显示某个包的详细信息
pkg files &lt;package&gt;             显示某个包的相关文件夹路径</code></pre><p>Bash</p>
<pre><code>~ &gt; echo $HOME
/data/data/com.termux/files/home

 ~ &gt; echo $PREFIX
/data/data/com.termux/files/usr

 ~ &gt; echo $TMPPREFIX
/data/data/com.termux/files/usr/tmp/zsh</code></pre><p>长期使用 Linux 的朋友可能会发现，这个 HOME 路径看上去可能不太一样, 为了方便,<code>Termux</code> 提供了一个特殊的环境变量:<code>PREFIX</code></p>
<p><img src="https://image.3001.net/images/20180502/15252398558622.png" alt></p>
<p>更换<code>Termux</code>清华大学源, 加快软件包下载速度.</p>
<h2 id="设置默认编辑器"><a href="#设置默认编辑器" class="headerlink" title="设置默认编辑器"></a><a href="#设置默认编辑器" title="设置默认编辑器"></a>设置默认编辑器</h2><h2 id="编辑源文件"><a href="#编辑源文件" class="headerlink" title="编辑源文件"></a><a href="#编辑源文件" title="编辑源文件"></a>编辑源文件</h2><p>将原来的<code>https://termux.net</code>官方源替换为<code>http://mirrors.tuna.tsinghua.edu.cn/termux</code></p>
<p>Bash</p>
<pre><code>export EDITOR=vi</code></pre><h2 id="直接编辑源文件"><a href="#直接编辑源文件" class="headerlink" title="直接编辑源文件"></a><a href="#直接编辑源文件" title="直接编辑源文件"></a>直接编辑源文件</h2><p>上面是官方推荐的方法, 其实还有更简单的方法, 类似于 Linux 下直接去编辑源文件:</p>
<p>Bash</p>
<pre><code>apt edit-sources</code></pre><p>如果清华源 出一些问题的话，大家可以尝试先用着官方源：</p>
<p>Bash</p>
<pre><code># The termux repository mirror from TUNA:
deb https://mirrors.tuna.tsinghua.edu.cn/termux stable main保存并退出</code></pre><p>Bash</p>
<pre><code>vi  $PREFIX/etc/apt/sources.list</code></pre><h2 id="终端配色"><a href="#终端配色" class="headerlink" title="终端配色"></a><a href="#终端配色" title="终端配色"></a>终端配色</h2><p>主要使用了<code>zsh</code>来替代<code>bash</code>作为默认<code>shell</code>.  
使用一键安装脚本来安装, 一步到位, 顺便启动了外置存储, 可以直接访问 SD 卡下的目录.</p>
<blockquote>
<p>执行下面这个命令确保已经安装好了 curl</p>
</blockquote>
<p>Bash</p>
<pre><code># The main termux repository:
deb https://termux.org/packages/ stable main</code></pre><p><img src="https://image.3001.net/images/20180501/15251492617193.png" alt></p>
<p>Android6.0 以上会弹框确认是否授权,</p>
<p><code>允许</code></p>
<p>授权后</p>
<p><code>Termux</code></p>
<p>可以方便的访问 SD 卡文件.</p>
<p>脚本允许后先后有如下两个选项:</p>
<pre><code>pkg update
pkg install vim curl wget git unzip unrar</code></pre><p>分别选择<code>背景色</code>和<code>字体</code><br>想要继续更改挑选配色的话, 继续运行脚本来再次筛选:</p>
<p>Bash</p>
<pre><code>sh -c &quot;$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)&quot;</code></pre><p><code>exit</code>重启<code>sessions</code>会话生效配置</p>
<h2 id="访问外置存储优化"><a href="#访问外置存储优化" class="headerlink" title="访问外置存储优化"></a><a href="#访问外置存储优化" title="访问外置存储优化"></a>访问外置存储优化</h2><p>执行过上面的<code>zsh</code>一键配置脚本后, 并且授予文件访问权限的话, 会在家目录生成<code>storage</code>目录，并且生成若干目录，软连接都指向外置存储卡的相应目录</p>
<p><img src="https://image.3001.net/images/20180501/15251507436942.png" alt></p>
<p><strong>创建 QQ 文件夹软连接</strong></p>
<p>手机上一般经常使用手机 QQ 来接收文件, 这里为了方便文件传输, 直接在<code>storage</code>目录下创建软链接.<br><strong>QQ</strong></p>
<p>Bash</p>
<pre><code>Enter a number, leave blank to not to change: 14
Enter a number, leave blank to not to change: 6</code></pre><p><strong>TIM</strong></p>
<p>Bash</p>
<pre><code>$ ~/termux-ohmyzsh/install.sh</code></pre><p>最后效果图如下:</p>
<p><img src="https://image.3001.net/images/20180501/15251516872451.png" alt></p>
<p>这样可以直接在</p>
<p><code>home</code></p>
<p>目录下去访问 QQ 文件夹, 非常方便文件的传输, 大大提升了工作效率.</p>
<p><a href="http://mirrors.tuna.tsinghua.edu.cn/termux" target="_blank" rel="noopener">http://mirrors.tuna.tsinghua.edu.cn/termux</a></p>
<h2 id="oh-my-zsh-主题配色"><a href="#oh-my-zsh-主题配色" class="headerlink" title="oh my zsh 主题配色"></a><a href="#oh-my-zsh主题配色" title="oh my zsh主题配色"></a>oh my zsh 主题配色</h2><p>编辑<code>.zshrc</code>配置文件</p>
<p>第一行可以看到, 默认的主题是<code>agnoster</code>主题:</p>
<p><img src="https://image.3001.net/images/20180501/15251531807018.png" alt></p>
<p>在</p>
<p><code>.oh-my-zsh/themes</code></p>
<p>目录下放着</p>
<p><code>oh-my-zsh</code></p>
<p>所有的主题配置文件.</p>
<p>下面是国光认为还不错的几款主题</p>
<p><strong>agnoster</strong></p>
<p><img src="https://image.3001.net/images/20180501/15251534292438.png" alt></p>
<p><strong>robbyrussell</strong></p>
<p><img src="https://image.3001.net/images/20180501/15251540733399.png" alt></p>
<p><strong>jaischeema</strong></p>
<p><img src="https://image.3001.net/images/20180501/15251541015433.png" alt></p>
<p><strong>re5et</strong></p>
<p><img src="https://image.3001.net/images/20180501/15251541397.png" alt></p>
<p><strong>junkfood</strong></p>
<p><img src="https://image.3001.net/images/20180501/15251541908342.png" alt></p>
<p><strong>cloud</strong></p>
<p><img src="https://image.3001.net/images/20180501/15251542579462.png" alt></p>
<p><strong>random</strong></p>
<p>当然如果你是个变态的话, 可以尝试<code>random</code>主题, 每打开一个会话配色主题都是随机的.</p>
<h2 id="修改启动问候语"><a href="#修改启动问候语" class="headerlink" title="修改启动问候语"></a><a href="#修改启动问候语" title="修改启动问候语"></a>修改启动问候语</h2><p>默认的启动问候语如下:</p>
<p><img src="https://image.3001.net/images/20180501/15251478499802.png" alt></p>
<p>这个对于初学者有一定的帮助在前期, 随着对</p>
<p><code>Termux</code></p>
<p>的熟悉, 这个默认的问候语就会显得比较臃肿.</p>
<p>编辑问候语文件直接修改问候语:</p>
<p>修改完的效果如下:</p>
<p><img src="https://image.3001.net/images/20180503/15253204397796.png" alt></p>
<p>这样启动新的会话的时候看上去就会简洁很多.</p>
<h2 id="手机没有-root"><a href="#手机没有-root" class="headerlink" title="手机没有 root"></a><a href="#手机没有root" title="手机没有root"></a>手机没有 root</h2><p>利用<code>proot</code>工具来模拟某些需要 root 的环境</p>
<p>然后终端下面输入:</p>
<p>即可模拟<code>root</code>环境<br>在这个<code>proot</code>环境下面, 相当于是进入了<code>home</code>目录, 可以很方便地进行一些配置.</p>
<p><img src="https://image.3001.net/images/20180502/15252406356840.png" alt></p>
<p>在管理员身份下，输入</p>
<p><code>exit</code></p>
<p>可回到普通用户身份。</p>
<h2 id="手机已经-root"><a href="#手机已经-root" class="headerlink" title="手机已经 root"></a><a href="#手机已经root" title="手机已经root"></a>手机已经 root</h2><p>安装<code>tsu</code>, 这是一个<code>su</code>的 termux 版本, 用来在 termux 上替代<code>su</code>:</p>
<p>然后终端下面输入:</p>
<p>即可切换<code>root</code>用户, 这个时候会弹出<code>root</code>授权提示, 给予其<code>root</code>权限, 效果图如下:</p>
<p><img src="https://image.3001.net/images/20180501/15251567018423.png" alt></p>
<p>在管理员身份下，输入</p>
<p><code>exit</code></p>
<p>可回到普通用户身份。</p>
<p>因为<code>termux</code>可以很好的支持<code>Python</code>, 所以几乎所有用<code>Python</code>编写的安全工具都是可以完美的运行使用的. 总的来说可玩性还是比较高的.</p>
<h2 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a><a href="#Metasploit" title="Metasploit"></a>Metasploit</h2><p><strong>安装Ｍetasploit</strong></p>
<p>Termux 官方提供的自动话脚本安装方法如下:</p>
<pre><code>ln -s /data/data/com.termux/files/home/storage/shared/tencent/QQfile_recv QQ</code></pre><blockquote>
<p>注　在 x86 平台下自动化安装失败，想在 x86 平台下安装的参考　<a href="https://wiki.termux.com/wiki/Metasploit_Framework" target="_blank" rel="noopener">官方的文档</a> 手动去安装．　　</p>
</blockquote>
<p>这个过程平均耗时大约 3 分钟左右（使用国内的清华源的情况下）．　　</p>
<p><strong>配置 msf 数据库缓存</strong></p>
<p>意外发现数据库居然都配置好了，启动<code>msfconsole会</code>自动连接数据库了．　　</p>
<p><img src="https://image.3001.net/images/20180502/15252619337456.png" alt></p>
<p>接下来重建数据库缓存</p>
<p>这个时候立刻去搜索发现缓存依然没有建立，只能使用慢速搜索，这里其实是这个缓存建立需要时间，只要稍微等待一下就可以了．</p>
<blockquote>
<p>国光以前这里做过测试，缓存建立的平均时间是 3 分钟左右．</p>
</blockquote>
<p>然后就可以实现<code>msf</code>秒搜索的效果了，无需等待，感觉比电脑上还要快呐　　</p>
<p><img src="https://image.3001.net/images/20180502/15252622202484.png" alt></p>
<h3 id="解决-metasploit-启动后无法连接数据库"><a href="#解决-metasploit-启动后无法连接数据库" class="headerlink" title="解决 metasploit 启动后无法连接数据库"></a><a href="#解决metasploit启动后无法连接数据库" title="解决metasploit启动后无法连接数据库"></a>解决 metasploit 启动后无法连接数据库</h3><p>使用自动化脚本安装好<code>Metasploit</code>后使用<code>db_status</code>发现数据库是处于连接状态的, 然后在使用<code>db_rebuild_cache</code>重新建立缓存, 等待大约 3 分钟后, 便可以使用快速搜索了, 没毛病~  
但是<br>在一段日子过后, 可能会出现以下情况:</p>
<p><img src="https://image.3001.net/images/20180507/15256704978052.png" alt></p>
<p>Bash</p>
<pre><code>ln -s /data/data/com.termux/files/home/storage/shared/tencent/TIMfile_recv TIM</code></pre><p>报这个错误是因为<code>postgresql</code>数据库没有启动造成的. 解决方法就是启动数据库:</p>
<blockquote>
<p>本方法只针对 termux 上使用自动化脚本安装 msf</p>
</blockquote>
<p>Bash</p>
<pre><code>$ vim .zshrc</code></pre><p>启动数据库后重新进入<code>msfconsole</code>会发现启动没有报错了,<code>db_status</code>查看下数据库连接, 也正常了:</p>
<p><img src="https://image.3001.net/images/20180507/1525670956965.png" alt></p>
<h2 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a><a href="#Nmap" title="Nmap"></a>Nmap</h2><p>端口扫描必备工具</p>
<p><img src="https://image.3001.net/images/20180502/15252522986960.png" alt></p>
<h2 id="hydra"><a href="#hydra" class="headerlink" title="hydra"></a><a href="#hydra" title="hydra"></a>hydra</h2><p>Hydra 是著名的黑客组织 THC 的一款开源暴力破解工具这是一个验证性质的工具，主要目的是：展示安全研究人员从远程获取一个系统认证权限。</p>
<p><img src="https://image.3001.net/images/20180502/1525253245778.png!" alt></p>
<h2 id="sslscan"><a href="#sslscan" class="headerlink" title="sslscan"></a><a href="#sslscan" title="sslscan"></a>sslscan</h2><p>SSLscan 主要探测基于 ssl 的服务，如 https。SSLscan 是一款探测目标服务器所支持的 SSL 加密算法工具。<br>SSlscan 的代码托管在 <a href="https://github.com/DinoTools/sslscan" target="_blank" rel="noopener">Github</a></p>
<p><img src="https://image.3001.net/images/20180502/15252523713030.png" alt></p>
<h2 id="whatportis"><a href="#whatportis" class="headerlink" title="whatportis"></a><a href="#whatportis" title="whatportis"></a>whatportis</h2><p>whatportis 是一款可以通过服务查询默认端口，或者是通过端口查询默认服务的工具，简单易用。在渗透测试过程中，如果需要查询某个端口绑定什么服务器，或者某个应用绑定的默认端口，可以使用 whatportis 查询。</p>
<p><img src="https://image.3001.net/images/20180502/1525254451611.png!" alt></p>
<h2 id="SQLmap"><a href="#SQLmap" class="headerlink" title="SQLmap"></a><a href="#SQLmap" title="SQLmap"></a>SQLmap</h2><p>SQLmap 是一款用来检测与利用 SQL 注入漏洞的免费开源工具 <a href="https://github.com/sqlmapproject/sqlmap" target="_blank" rel="noopener">官方项目地址</a></p>
<p>直接<code>git clone</code>源码</p>
<pre><code>ZSH_THEME=&quot;random&quot;</code></pre><blockquote>
<p>sqlmap 支持 pip 安装了, 所以建议直接 pip install sqlmap 来进行安装, 然后终端下直接 sqlmap 就可以了, 十分方便.</p>
</blockquote>
<p><img src="https://image.3001.net/images/20180502/15252521782388.png" alt></p>
<h2 id="RouterSploit"><a href="#RouterSploit" class="headerlink" title="RouterSploit"></a><a href="#RouterSploit" title="RouterSploit"></a>RouterSploit</h2><p>RouteSploit 框架是一款开源的路由器等嵌入式设备漏洞检测及利用框架。</p>
<p>Bash</p>
<pre><code>vim $PREFIX/etc/motd</code></pre><p><img src="https://image.3001.net/images/20180502/15252536832530.png" alt></p>
<h2 id="Slowloris"><a href="#Slowloris" class="headerlink" title="Slowloris"></a><a href="#Slowloris" title="Slowloris"></a>Slowloris</h2><p>低带宽的 DoS 工具</p>
<pre><code>pkg install proot</code></pre><p><img src="https://image.3001.net/images/20180502/15252663642248.png" alt></p>
<h2 id="RED-HAWK"><a href="#RED-HAWK" class="headerlink" title="RED_HAWK"></a><a href="#RED-HAWK" title="RED_HAWK"></a>RED_HAWK</h2><p>一款采用 PHP 语言开发的多合一型渗透测试工具，它可以帮助我们完成信息采集、SQL 漏洞扫描和资源爬取等任务。</p>
<p>Bash</p>
<pre><code>termux-chroot</code></pre><p><img src="https://image.3001.net/images/20180502/1525267319924.png!" alt></p>
<h2 id="Cupp"><a href="#Cupp" class="headerlink" title="Cupp"></a><a href="#Cupp" title="Cupp"></a>Cupp</h2><p>Cupp 是一款用 Python 语言写成的可交互性的字典生成脚本。尤其适合社会工程学，当你收集到目标的具体信息后，你就可以通过这个工具来智能化生成关于目标的字典。</p>
<pre><code>pkg install tsu</code></pre><p><img src="https://image.3001.net/images/20180502/15252677611697.png" alt></p>
<h2 id="Hash-Buster"><a href="#Hash-Buster" class="headerlink" title="Hash-Buster"></a><a href="#Hash-Buster" title="Hash-Buster"></a>Hash-Buster</h2><p>Hash Buster 是一个用 python 编写的在线破解 Hash 的脚本，官方说 5 秒内破解, 速度实际测试还不错哦~</p>
<pre><code>tsu</code></pre><p><img src="https://image.3001.net/images/20180502/15252684925926.png" alt></p>
<h2 id="D-TECT"><a href="#D-TECT" class="headerlink" title="D-TECT"></a><a href="#D-TECT" title="D-TECT"></a>D-TECT</h2><p>D-TECT 是一个用 Python 编写的先进的渗透测试工具,</p>
<ul>
<li>wordpress 用户名枚举</li>
<li>敏感文件检测</li>
<li>子域名爆破</li>
<li>端口扫描</li>
<li>Wordperss 扫描</li>
<li>XSS 扫描</li>
<li>SQL 注入扫描等</li>
</ul>
<pre><code>cd ～
pkg install wget
wget https://Auxilus.github.io/metasploit.sh
bash metasploit.sh</code></pre><p><img src="https://image.3001.net/images/20180502/152526900352.png" alt></p>
<h2 id="WPSeku"><a href="#WPSeku" class="headerlink" title="WPSeku"></a><a href="#WPSeku" title="WPSeku"></a>WPSeku</h2><p>WPSeku 是一个用 Python 写的简单的 WordPress 漏洞扫描器，它可以被用来扫描本地以及远程安装的 WordPress 来找出安全问题。被评为 2017 年最受欢迎的十大开源黑客工具.</p>
<p>Bash</p>
<pre><code>msf &gt; db_rebuild_cache</code></pre><p><img src="https://image.3001.net/images/20180502/15252705506839.png" alt></p>
<h2 id="XSStrike"><a href="#XSStrike" class="headerlink" title="XSStrike"></a><a href="#XSStrike" title="XSStrike"></a>XSStrike</h2><p>XSStrike 是一种先进的 XSS 检测工具。它具有强大的模糊测试引擎.</p>
<p>Bash</p>
<pre><code>msfconsole
[-] Failed to connect to the database: could not connect to server: Connection refused
        Is the server running on host &quot;127.0.0.1&quot; and accepting
        TCP/IP connections on port 5432?</code></pre><p><img src="https://image.3001.net/images/20180502/15252722868294.png" alt></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><a href="#小结" title="小结"></a>小结</h2><p>因为 Termux 完美的支持<code>Python</code>和<code>Perl</code>等语言, 所以有太多优秀的信息安全工具值得大家去发现了, 这里我就不一一列举了.</p>
<h2 id="安装-python2-7"><a href="#安装-python2-7" class="headerlink" title="安装 python2.7"></a><a href="#安装python2-7" title="安装python2.7"></a>安装 python2.7</h2><p>安装完成后, 使用<code>python2</code>命令启动<code>python 2.7.14</code>环境.</p>
<p><img src="https://image.3001.net/images/20180501/15251677413951.png" alt></p>
<h2 id="安装-python3"><a href="#安装-python3" class="headerlink" title="安装 python3"></a><a href="#安装python3" title="安装python3"></a>安装 python3</h2><p>安装完成后, 使用<code>python</code>命令启动<code>python 3.6.5</code>环境.</p>
<p><img src="https://image.3001.net/images/20180501/152516780621.png" alt></p>
<h2 id="升级-pip-版本"><a href="#升级-pip-版本" class="headerlink" title="升级 pip 版本"></a><a href="#升级pip版本" title="升级pip版本"></a>升级 pip 版本</h2><p>Bash</p>
<pre><code>pg_ctl -D $PREFIX/var/lib/postgresql start</code></pre><p>这两条命令分别升级了<code>pip2</code>和<code>pip3</code>到最新版.<br><strong>pip 版本查看</strong></p>
<p><img src="https://image.3001.net/images/20180501/15251709032749.png" alt></p>
<h2 id="ipython"><a href="#ipython" class="headerlink" title="ipython"></a><a href="#ipython" title="ipython"></a>ipython</h2><p>ipython 是一个 python 的交互式 shell，支持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多很有用的功能和函数。学习 ipython 将会让我们以一种更高的效率来使用 python。<br>先安装<code>clang</code>, 否则直接使用<code>pip</code>安装<code>ipython</code>会失败报错.</p>
<pre><code>pkg install nmap</code></pre><p>然后分别使用<code>ipython</code>和<code>ipython2</code>进入<code>py2</code>和<code>py3</code>控制台:</p>
<p><img src="https://image.3001.net/images/20180501/15251711666731.png" alt></p>
<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a><a href="#编辑器" title="编辑器"></a>编辑器</h2><p>终端下有<code>vim</code>神器, 并且官方也已经封装了<code>vim-python</code>, 对<code>vim</code>进行了 Python 相关的优化.</p>
<p>Bash</p>
<pre><code>pkg install hydra</code></pre><p><strong>解决 termux 下的 vim 汉字乱码</strong></p>
<p>在家目录下, 新建<code>.vimrc</code>文件</p>
<p>添加内容如下:</p>
<pre><code>pkg install sslscan</code></pre><p>然后<code>source</code>下变量:</p>
<p><strong>效果图</strong></p>
<p><img src="https://image.3001.net/images/20180501/15251690917140.png" alt></p>
<h2 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a><a href="#安装nodejs" title="安装nodejs"></a>安装 nodejs</h2><p>安装比较方便, 但是在安装的时候报错了</p>
<pre><code>pip2 install whatportis</code></pre><p>查了下是这边版本的问题</p>
<p><img src="https://image.3001.net/images/20180501/15251603187936.png" alt></p>
<p>官方的解决方法如下</p>
<p><a href="https://github.com/rvagg/node-worker-farm/commit/0b2349c6c7ed5c51e234e418fad226875313e773" target="_blank" rel="noopener">disable concurrency in case of libuv/libuv#1459</a></p>
<p><img src="https://image.3001.net/images/20180501/15251607456224.png" alt></p>
<h2 id="解决-npm-安装报错"><a href="#解决-npm-安装报错" class="headerlink" title="解决 npm 安装报错"></a><a href="#解决npm安装报错" title="解决npm安装报错"></a>解决 npm 安装报错</h2><p>Bash</p>
<pre><code>git clone https://github.com/sqlmapproject/sqlmap.git
cd sqlmap
python2 sqlmap.py</code></pre><p>我这里修改 length 的是<code>4</code>, 这个好像和 CPU 有关, 总之这里的 length 得指定一个数字.</p>
<p><img src="https://image.3001.net/images/20180501/15251608278605.png" alt></p>
<p>然后在重新安装下</p>
<p><code>npm install hexo-cli -g</code></p>
<p>成功.</p>
<p>MariaDB 数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用 GPL 授权许可。开发这个分支的原因之一是：甲骨文公司收购了 MySQL 后，有将 MySQL 闭源的潜在风险，因此社区采用分支的方式来避开这个风险。</p>
<h2 id="安装-mariadb"><a href="#安装-mariadb" class="headerlink" title="安装 mariadb"></a><a href="#安装mariadb" title="安装mariadb"></a>安装 mariadb</h2><h2 id="安装基本数据"><a href="#安装基本数据" class="headerlink" title="安装基本数据"></a><a href="#安装基本数据" title="安装基本数据"></a>安装基本数据</h2><h2 id="启动-mariadb-服务"><a href="#启动-mariadb-服务" class="headerlink" title="启动 mariadb 服务"></a><a href="#启动mariadb服务" title="启动mariadb服务"></a>启动 mariadb 服务</h2><p>启动完成后, 这个会话就一直存活, 类似与 debug 调试一样, 只有新建会话才可以操作.</p>
<p><img src="https://image.3001.net/images/20180501/15251762051594.png" alt></p>
<p>关于隐藏会话可以使用</p>
<p><code>nohup</code></p>
<p>命令和</p>
<p><code>tmux</code></p>
<p>命令, 这里我建议使用</p>
<p><code>tmux</code></p>
<p>命令</p>
<h2 id="新建-termux-会话"><a href="#新建-termux-会话" class="headerlink" title="新建 termux 会话"></a><a href="#新建termux会话" title="新建termux会话"></a>新建 termux 会话</h2><p>由于 mariadb 安装的时候没有设置密码, 当前的<code>mariadb</code>密码为<code>空</code>.</p>
<p>直接进入<code>mariadb</code>数据库. 输入<code>exit</code>退出数据库.</p>
<p><img src="https://image.3001.net/images/20180501/15251770923501.png" alt></p>
<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a><a href="#修改密码" title="修改密码"></a>修改密码</h2><p>输入一下命令, 进行密码相关的安全设置:</p>
<p>Bash</p>
<pre><code>pip2 install requests
git clone https://github.com/reverse-shell/routersploit
cd routersploit
python2 rsf.py</code></pre><p><strong>输入当前输入密码</strong><br>因为是<code>空</code>密码, 这里默认 <code>回车</code></p>
<p>Bash</p>
<pre><code>git clone https://github.com/gkbrk/slowloris.git
cd slowloris
chmod +x slowloris.py</code></pre><p><strong>设置新密码</strong><br>这里设置新的 root 密码</p>
<p>Bash</p>
<pre><code>pkg install php
git clone https://github.com/Tuhinshubhra/RED_HAWK.git
cd RED_HAWK
php rhawk.php</code></pre><p><strong>其他设置</strong><br>下面根据个人偏好来进行设置, 没有绝对的要求</p>
<p>Bash</p>
<pre><code>git clone https://github.com/Mebus/cupp.git
cd cupp
python2 cupp.py</code></pre><h2 id="使用密码登录数据库"><a href="#使用密码登录数据库" class="headerlink" title="使用密码登录数据库"></a><a href="#使用密码登录数据库" title="使用密码登录数据库"></a>使用密码登录数据库</h2><p>Mysql</p>
<pre><code>git clone https://github.com/UltimateHackers/Hash-Buster.git
cd Hash-Buster
python2 hash.py</code></pre><p><img src="https://image.3001.net/images/20180501/15251777161538.png" alt></p>
<p>Tmux 是一个优秀的终端复用软件，类似 GNU Screen，但来自于 OpenBSD，采用 BSD 授权。一旦你熟悉了 tmux 后， 它就像一个加速器一样加速你的工作效率。</p>
<h2 id="安装-tmux"><a href="#安装-tmux" class="headerlink" title="安装 tmux"></a><a href="#安装tmux" title="安装tmux"></a>安装 tmux</h2><h2 id="新建-mysql-会话"><a href="#新建-mysql-会话" class="headerlink" title="新建 mysql 会话"></a><a href="#新建mysql会话" title="新建mysql会话"></a>新建 mysql 会话</h2><p>上面介绍的<code>mysqld</code>后会一直卡在那里, 强迫症表示接受不了,<code>重启手机</code>, 现在尝试使用<code>tmux</code>来管理会话.</p>
<p>可以看到最下面的提示, 表明现在是在<code>mysql</code>的会话下面操作</p>
<p><img src="https://image.3001.net/images/20180501/15251785128162.png" alt></p>
<h2 id="启动-mysqld-并断开会话"><a href="#启动-mysqld-并断开会话" class="headerlink" title="启动 mysqld 并断开会话"></a><a href="#启动mysqld并断开会话" title="启动mysqld并断开会话"></a>启动 mysqld 并断开会话</h2><p><strong>启动 mysqld</strong></p>
<p><strong>让会话后台运行</strong><br>使用快捷键组合<code>Ctrl</code>+<code>b</code> + <code>d</code>，三次按键就可以断开当前会话。</p>
<h2 id="使用-mysql"><a href="#使用-mysql" class="headerlink" title="使用 mysql"></a><a href="#使用mysql" title="使用mysql"></a>使用 mysql</h2><p>现在那个<code>mysqld</code>会话被放在后台运行了, 整个界面看上去很简介, 使用</p>
<p>可以优雅的使用数据库了.<br><strong>效果图</strong></p>
<p><img src="https://image.3001.net/images/20180501/15251788017133.gif" alt></p>
<p>关于</p>
<p><code>tmux</code></p>
<p>更多进阶的用法这里不在过多介绍了.</p>
<p><code>termux</code>封装的 php 版本是<code>php 7.2.5</code></p>
<h2 id="安装-PHP"><a href="#安装-PHP" class="headerlink" title="安装 PHP"></a><a href="#安装PHP" title="安装PHP"></a>安装 PHP</h2><p><strong>查看下版本</strong></p>
<p><img src="https://image.3001.net/images/20180501/15251829165152.png" alt></p>
<blockquote>
<p>自<code>PHP5.4</code>之后 PHP 内置了一个 Web 服务器, 来在<code>termux</code>下尝试下 PHP Web Server 的简单使.</p>
</blockquote>
<h2 id="编写测试文件"><a href="#编写测试文件" class="headerlink" title="编写测试文件"></a><a href="#编写测试文件" title="编写测试文件"></a>编写测试文件</h2><p>在家目录下建一个<code>www</code>文件夹:<code>mkdir www</code><br>在<code>www</code>文件夹下新建一个<code>index.php</code>文件, 其内容为</p>
<p><img src="https://image.3001.net/images/20180501/15251831922563.png" alt></p>
<h2 id="启动-WebServer"><a href="#启动-WebServer" class="headerlink" title="启动 WebServer"></a><a href="#启动WebServer" title="启动WebServer"></a>启动 WebServer</h2><pre><code>git clone https://github.com/shawarkhanethicalhacker/D-TECT.git
cd D-TECT
python2 d-tect.py</code></pre><p>浏览器访问效果如下:</p>
<p><img src="https://image.3001.net/images/20180501/15251833614865.png" alt></p>
<p>Nginx 是一个高性能的 Web 和反向代理服务器, 它具有有很多非常优越的特性.</p>
<h2 id="安装-nginx-包"><a href="#安装-nginx-包" class="headerlink" title="安装 nginx 包"></a><a href="#安装nginx包" title="安装nginx包"></a>安装 nginx 包</h2><h2 id="切换-root-用户"><a href="#切换-root-用户" class="headerlink" title="切换 root 用户"></a><a href="#切换root用户" title="切换root用户"></a>切换 root 用户</h2><p>尝试下能不能解析默认的<code>index.html</code>主页<br>这个文件在<code>termux</code>上的默认位置为<code>/data/data/com.termux/files/usr/share/nginx/html/index.html</code><br><strong>切换 root 用户</strong></p>
<blockquote>
<p>默认的普通权限无法启动 nginx, 需要模拟<code>root</code>权限才可以</p>
</blockquote>
<p>没有这个命令的话, 手动安装<code>pkg install proot</code>包</p>
<p>进入模拟的 root 环境</p>
<h2 id="启动-nginx"><a href="#启动-nginx" class="headerlink" title="启动 nginx"></a><a href="#启动nginx" title="启动nginx"></a>启动 nginx</h2><p>在模拟的 root 环境下启动<code>nginx</code></p>
<p><code>termux</code>上<code>nginx</code>默认的端口是<code>8080</code><br>查看下<code>8080</code>端口是否在运行</p>
<p>Bash</p>
<pre><code>git clone https://github.com/m4ll0k/WPSeku.git
cd WPSeku
pip3 install -r requirements.txt
python3 wpseku.py</code></pre><p><img src="https://image.3001.net/images/20180502/15252383228620.png" alt></p>
<p>然后手机本地直接访问:</p>
<p><code>http://127.0.0.1:8080</code></p>
<p>查看下</p>
<p><code>nginx</code></p>
<p>是否正常启动.</p>
<p><strong>效果图</strong></p>
<p><img src="https://image.3001.net/images/20180502/15252318618015.png" alt></p>
<p>这样一个默认的</p>
<p><code>nginx</code></p>
<p>服务就起来了, 但是意义不大, 得配置一下可以解析</p>
<p><code>php</code></p>
<p>才会有更大的意义.</p>
<h2 id="停止-nginx-服务"><a href="#停止-nginx-服务" class="headerlink" title="停止 nginx 服务"></a><a href="#停止nginx服务" title="停止nginx服务"></a>停止 nginx 服务</h2><p>这里是直接杀掉占用端口的进程, 具体端口以实际情况为准.</p>
<h2 id="重启-nginx-服务"><a href="#重启-nginx-服务" class="headerlink" title="重启 nginx 服务"></a><a href="#重启nginx服务" title="重启nginx服务"></a>重启 nginx 服务</h2><p><code>nginx</code>解析<code>PHP</code>这里单独拿出一级标题来叙述, 成功解析的话, 下面安装<code>wordpress</code>等 cms 就会轻松很多.<br>nginx 本身不能处理 PHP，它只是个 web 服务器，当接收到 php 请求后发给 php 解释器处理, nginx 一般是把请求发 fastcgi 管理进程处理, PHP-FPM 是一个 PHP FastCGI 管理器, 所以这里得先安装<code>php-fpm</code>.</p>
<blockquote>
<p>这里默已经安装了 nginx 和 php, 没有安装的话, 使用<code>pkg install php nginx</code>来进行安装, 参考上面部分进行配置</p>
</blockquote>
<h2 id="安装并配置-php-fpm"><a href="#安装并配置-php-fpm" class="headerlink" title="安装并配置 php-fpm"></a><a href="#安装并配置php-fpm" title="安装并配置php-fpm"></a>安装并配置 php-fpm</h2><p><strong>安装 php-fpm</strong></p>
<p><strong>配置 php-fpm</strong><br>进入<code>proot</code>环境, 然后编辑配置文件<code>www.conf</code>(先进 proot 可以更方便操作编写相关配置文件)</p>
<p>Bash</p>
<pre><code>git clone https://github.com/UltimateHackers/XSStrike.git
cd XSStrike
pip2 install -r requirements.txt
python2 xsstrike</code></pre><p>定位搜索<code>listen</code>找到</p>
<pre><code>pkg install python2</code></pre><p>将其改为</p>
<h2 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a><a href="#配置nginx" title="配置nginx"></a>配置 nginx</h2><p>在<code>proot</code>环境下, 然后编辑配置文件<code>nginx.conf</code></p>
<pre><code>pkg install python</code></pre><p>下面给出已经配置好的模板文件, 直接编辑替换整个文件即可:</p>
<p>Bash</p>
<pre><code>python2 -m pip install --upgrade pip
python -m pip install --upgrade pip</code></pre><p>里面的网站默认路径就是<code>nginx</code>默认的网站根目录:</p>
<p>Bash</p>
<pre><code>pkg install clang
pip install ipython
pip3.6 install ipython</code></pre><p>要修改网站默认路径的话, 只需要修改这两处即可.</p>
<h2 id="建立-php-测试文件"><a href="#建立-php-测试文件" class="headerlink" title="建立 php 测试文件"></a><a href="#建立php测试文件" title="建立php测试文件"></a>建立 php 测试文件</h2><p>在<code>/usr/share/nginx/html</code>目录下新建一个<code>phpinfo.php</code>文件, 其内容是:<code>&lt;?php phpinfo();?&gt;</code></p>
<p><img src="https://image.3001.net/images/20180502/15252458901236.png" alt></p>
<p>went</p>
<h2 id="启动-php-fpm-和-nginx"><a href="#启动-php-fpm-和-nginx" class="headerlink" title="启动 php-fpm 和 nginx"></a><a href="#启动php-fpm和nginx" title="启动php-fpm和nginx"></a>启动 php-fpm 和 nginx</h2><p>在<code>proot</code>环境下面分别启动<code>php-fpm</code>和<code>nginx</code>, 这里的<code>nginx</code>不在<code>proot</code>环境下启动后会出一些问题, 感兴趣的可以自己去研究看看.</p>
<h2 id="浏览器访问测试"><a href="#浏览器访问测试" class="headerlink" title="浏览器访问测试"></a><a href="#浏览器访问测试" title="浏览器访问测试"></a>浏览器访问测试</h2><p>浏览器访问<code>http://127.0.0.1:8080/phpinfo.php</code> 查询<code>php</code>文件是否解析了.</p>
<p><img src="https://image.3001.net/images/20180502/15252463292840.png" alt></p>
<p>这里只是用<code>wordpress</code>做个典型安利来讲解, 类似地可以安装<code>Discuz</code>,<code>DeDecms</code>等国内主流的 PHP 应用程序.</p>
<h2 id="方法一-使用-PHP-内置的-Web-Server"><a href="#方法一-使用-PHP-内置的-Web-Server" class="headerlink" title="方法一 使用 PHP 内置的 Web Server"></a><a href="#方法一-使用PHP内置的Web-Server" title="方法一 使用PHP内置的Web Server"></a>方法一 使用 PHP 内置的 Web Server</h2><p>确保安装并配置了<code>php</code>和<code>mariadb</code>, 没有安装好的话, 参考本文中具体细节部分来进行安装.<br><strong>新建数据库</strong></p>
<blockquote>
<p><code>***</code> 这里是 mysql 的密码</p>
</blockquote>
<p>Sql</p>
<pre><code>pkg install vim-python</code></pre><p><strong>下载解压 wordpress</strong></p>
<p>Bash</p>
<pre><code>vim .vimrc</code></pre><p><strong>启动 PHP Web Server</strong><br>到解压后的<code>wordpress</code>目录下, 执行</p>
<p>Bash</p>
<pre><code>set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1
set enc=utf8
set fencs=utf8,gbk,gb2312,gb18030</code></pre><p>然后浏览器访问<code>127.0.0.1:8080</code>开始进行<code>wordperss</code>的安装.<br><strong>效果图</strong></p>
<p><img src="https://image.3001.net/images/20180501/15251896513740.png" alt></p>
<h2 id="方法二-nginx-PHP-Mariadb"><a href="#方法二-nginx-PHP-Mariadb" class="headerlink" title="方法二 nginx+PHP+Mariadb"></a><a href="#方法二-nginx-PHP-Mariadb" title="方法二 nginx+PHP+Mariadb"></a>方法二 nginx+PHP+Mariadb</h2><p>上面使用的方法一是直接使用 PHP 自带的<code>PHP Web Server</code>来运行的, 看上去不够严谨~, 所以这里用<code>nginx</code>来部署<code>wordpress</code>.  
确保安装了<code>PHP</code>,<code>php-fpm</code>,<code>mariadb</code>, 没有安装的话, 参考本文中具体细节部分来进行安装和配置.<br><strong>新建数据</strong>和 <strong>wordpress 下载</strong>参考上面的<code>方法一</code>, 这里主要介绍使用<code>nginx</code>去解析<code>wordpress</code>源文件.<br>当前解压后<code>wordpress</code>的绝对路径是:</p>
<p>Bash</p>
<pre><code>source .vimrc</code></pre><p><strong>编辑 nginx.conf</strong></p>
<p>Bash</p>
<pre><code>pkg install nodejs</code></pre><p>修改为如下几处:</p>
<pre><code>Cannot read property &#39;length&#39; of undefined</code></pre><p><img src="https://image.3001.net/images/20180502/15252481801600.png" alt></p>
<p><strong>启动 php-fpm 和 nginx</strong></p>
<p>在</p>
<p><code>proot</code></p>
<p>环境下面分别启动</p>
<p><code>php-fpm</code></p>
<p>和</p>
<p><code>nginx</code></p>
<p>, 这里的</p>
<p><code>nginx</code></p>
<p>不在</p>
<p><code>proot</code></p>
<p>环境下启动后会出一些问题, 感兴趣的可以自己去研究看看.</p>
<p><strong>安装 wordpress</strong><br>浏览器访问:<code>http://127.0.0.1:8080/wp-admin/setup-config.php</code>进行安装.<br><strong>效果图</strong></p>
<p><img src="https://image.3001.net/images/20180502/15252484266727.png" alt></p>
<p>同理安装其他博客也就轻而易举了, 可玩性大大增加~</p>
<h2 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a><a href="#安装hexo" title="安装hexo"></a>安装 hexo</h2><h2 id="部署-hexo-博客环境"><a href="#部署-hexo-博客环境" class="headerlink" title="部署 hexo 博客环境"></a><a href="#部署hexo博客环境" title="部署hexo博客环境"></a>部署 hexo 博客环境</h2><p>然后建立一个目录, 然后到这个目录下初始化 hexo 环境</p>
<pre><code>vim $PREFIX/lib/node_modules/npm/node_modules/worker-farm/lib/farm.js</code></pre><p><img src="https://image.3001.net/images/20180502/15251904412057.png" alt></p>
<p>然后就跑起来一个最基本的 hexo 博客</p>
<p>关于 hexo 博客的详细教程, 建议搭建去参考 hexo 官方文档, 我这里重点在于 termux 其他的不作过多的叙述.</p>
<p><strong>效果图</strong></p>
<p><img src="https://image.3001.net/images/20180502/1525190501582.png!" alt></p>
<p>有时候要操作电脑, 这个时候有了<code>termux</code>, 躺在床上就可以操作电脑了, 岂不是美滋滋~~  
安装<code>openssh</code></p>
<p>然后就可以直接 ssh 连接你的电脑了</p>
<blockquote>
<p>前提是电脑安装了 ssh 服务</p>
</blockquote>
<p>Bash</p>
<pre><code>pkg install mariadb</code></pre><p>手机连接操作电脑效果图:</p>
<p><img src="https://image.3001.net/images/20180501/15251634576779.png" alt></p>
<p>emmm 这个需求比较鸡肋, 但是写文字嘛就得写全了~</p>
<p><strong>安装 openssh</strong></p>
<p>同样也需要<code>openssh</code>才可以</p>
<p><strong>启动 sshd</strong></p>
<p>安装完成后,<code>sshd</code>服务默认没有启动, 所以得手动启动下:</p>
<p>因为手机上面低的端口有安全限制, 所以这里的<code>openssh</code>默认的<code>sshd</code>默认的服务是<code>8022</code>端口上的.<br><code>ssh</code>的用户名用<code>whoami</code>命令看下.</p>
<p><img src="https://image.3001.net/images/20180501/15251646896319.png" alt></p>
<p>可以看到</p>
<p><code>sshd</code></p>
<p>启动后, 端口才可以看到.</p>
<p><strong>PC 端生成公钥</strong></p>
<p><code>ssh</code>登录是 key 公钥模式登录, 首先在 PC 端生成秘钥:</p>
<p>Bash</p>
<pre><code>mysql_install_db</code></pre><p>执行完成后，会在家目录下创建 3 个文件<br><code>id_rsa</code>, <code>id_rsa.pub</code> , <code>known_hosts</code></p>
<p><img src="https://image.3001.net/images/20180501/15251652383913.png" alt></p>
<p><strong>拷贝公钥到手机</strong></p>
<p>然后把公钥<code>id_rsa.pub</code>拷贝到手机的<code>data\data\com.termux\files\home\.ssh</code>文件夹中.</p>
<p><strong>将公钥拷贝到验证文件中</strong></p>
<p>在<code>Termux</code>下操作</p>
<p>Bash</p>
<pre><code>mysqld</code></pre><p><img src="https://image.3001.net/images/20180501/15251669649531.png" alt></p>
<p><strong>PC 端连接手机 termux</strong></p>
<p>Bash</p>
<pre><code>mysql</code></pre><p><strong>效果图</strong></p>
<p><img src="https://image.3001.net/images/20180501/15251672621339.png" alt></p>
<p>pc 端连接手机 termux 真心鸡肋呀~(忍不住自己吐槽下自己)</p>
<p>Aria2 是一个轻量级多协议和多源命令行下载实用工具。它支持 HTTP / HTTPS, FTP, SFTP, bt 和 Metalink。通过内置 Aria2 可以操作 json - rpc 和 xml - rpc。配置好的话还可以高速下载百度云文件.</p>
<h2 id="安装-aria2"><a href="#安装-aria2" class="headerlink" title="安装 aria2"></a><a href="#安装aria2" title="安装aria2"></a>安装 aria2</h2><h2 id="本地启动服务"><a href="#本地启动服务" class="headerlink" title="本地启动服务"></a><a href="#本地启动服务" title="本地启动服务"></a>本地启动服务</h2><p>Bash</p>
<pre><code>mysql_secure_installation</code></pre><p>这个<code>rpc</code>服务默认监听的是<code>6800</code>端口, 启动后方便下面的 Web 界面连接操作.</p>
<h2 id="webui-aria2"><a href="#webui-aria2" class="headerlink" title="webui-aria2"></a><a href="#webui-aria2" title="webui-aria2"></a>webui-aria2</h2><p>这是个 Aria2 的热门项目, 把 Aria2 封装在了 Web 平台, 操作起来更加简单便捷。</p>
<pre><code>Enter current password for root (enter for none):</code></pre><blockquote>
<p>需要 node 来运行, 没有安装的 话使用<code>pkg install nodejs</code>来安装</p>
</blockquote>
<p>使用效果图 , 速度蛮快的 , 有兴趣的可以研究如何利用<code>aria2</code>来下载百度云文件, 等你们来探索.</p>
<p><img src="https://image.3001.net/images/20180502/15252753579498.png" alt></p>
<p><a href="https://github.com/mholt/caddy" target="_blank" rel="noopener">官方项目地址</a></p>
<h2 id="安装-caddy"><a href="#安装-caddy" class="headerlink" title="安装 caddy"></a><a href="#安装caddy" title="安装caddy"></a>安装 caddy</h2><p>官方: 到目前为止，在 Android 上运行 Caddy 有两种方式：<code>Termux</code>和<code>adb</code>, 所以那就顺便折腾一下看看吧:</p>
<p>Bash</p>
<pre><code>Set root password? [Y/n] y
New password:
Re-enter new password:</code></pre><p>这一步可能执行要<code>3</code>番钟左右, 耐心等待一下即可.</p>
<h2 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a><a href="#编写配置文件" title="编写配置文件"></a>编写配置文件</h2><p>内容如下:</p>
<p>Bash</p>
<pre><code>Remove anonymous users? [Y/n] Y                #是否移除匿名用户
Disallow root login remotely? [Y/n] n          #是否不允许root远程登录
Remove test database and access to it? [Y/n] n #是否移除test数据库
Reload privilege tables now? [Y/n] y           #是否重新加载表的权限</code></pre><p>这里的<code>8080</code>端口号可以随意指定, 因为手机权限比较低, 所以一般设置<code>1024</code>以上的端口.</p>
<p>注意<code>8080</code>和<code>{</code>之间有一个<code>空格</code></p>
<p>注意<code>/ / sdcard</code> 两个斜杠之间也有一个空格</p>
<h2 id="启动-caddy"><a href="#启动-caddy" class="headerlink" title="启动 caddy"></a><a href="#启动caddy" title="启动caddy"></a>启动 caddy</h2><p><img src="https://image.3001.net/images/20180503/15253177578355.png" alt></p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a><a href="#效果" title="效果"></a>效果</h2><p>浏览器访问:<code>http://127.0.0.1:8080</code>即可, 局域网内的用户访问手机 ip 地址即可.</p>
<p>默认账号和密码为<code>admin</code>,<code>admin</code>.</p>
<p><img src="https://image.3001.net/images/20180503/15253179015491.png" alt></p>
<p>可以在设置界面里面 <code>设置简体中文</code>, 可以修改<code>更新默认密码</code>.</p>
<p>可以直接查看文件, 也支持<code>Linux</code>命令搜索.</p>
<p><img src="https://image.3001.net/images/20180503/15253180376304.png" alt></p>
<p><img src="https://image.3001.net/images/20180503/1525317995747.png!" alt></p>
<p>Termux:API，用于访问手机硬件, 实现更多的可玩性, 可以实现如下等功能:</p>
<ul>
<li>访问电池信息</li>
<li>获取相机设备信息</li>
<li>获取本机设备信息</li>
<li>获取设置剪贴板信息</li>
<li>获取通讯录信息</li>
<li>获取设置手机短信</li>
<li>拨打号码</li>
<li>振动设备</li>
</ul>
<h2 id="安装-Termux-api"><a href="#安装-Termux-api" class="headerlink" title="安装 Termux-api"></a><a href="#安装Termux-api" title="安装Termux-api"></a>安装 Termux-api</h2><p><a href="https://play.google.com/store/apps/details?id=com.termux.api" target="_blank" rel="noopener">Termux-api Google Play 下载地址</a></p>
<p><img src="https://image.3001.net/images/20180503/15253115369877.png" alt></p>
<blockquote>
<p>补充一下链接<a href="https://www.zhihu.com/question/22382577" target="_blank" rel="noopener">如何在电脑上下载 Google play 上的应用？</a></p>
</blockquote>
<h2 id="安装-Termux-api-软件包"><a href="#安装-Termux-api-软件包" class="headerlink" title="安装 Termux-api 软件包"></a><a href="#安装Termux-api软件包" title="安装Termux-api软件包"></a>安装 Termux-api 软件包</h2><p>安装完<code>Termux-api</code>APP 后,<code>Termux</code>里面必须安装对应的包后才可以实现操作手机底层.</p>
<p>Bash</p>
<pre><code>$ mysql -uroot -p
Enter password: ***apache2</code></pre><p>下面只列举一些可能会用到的, 想要获取更多关于<code>Termux-api</code>的话, 那就去参考官方文档.</p>
<h2 id="获取电池信息"><a href="#获取电池信息" class="headerlink" title="获取电池信息"></a><a href="#获取电池信息" title="获取电池信息"></a>获取电池信息</h2><p>Bash</p>
<pre><code>pkg install tmux</code></pre><p>可以看到电池的 - 健康状况 - 电量百分比 - 温度情况等</p>
<p>Bash</p>
<pre><code>tmux new -s mysql</code></pre><h2 id="获取相机信息"><a href="#获取相机信息" class="headerlink" title="获取相机信息"></a><a href="#获取相机信息" title="获取相机信息"></a>获取相机信息</h2><h2 id="获取与设置剪贴板"><a href="#获取与设置剪贴板" class="headerlink" title="获取与设置剪贴板"></a><a href="#获取与设置剪贴板" title="获取与设置剪贴板"></a>获取与设置剪贴板</h2><p><strong>查看当前剪贴板内容</strong></p>
<p><strong>设置新的剪贴板内容</strong></p>
<pre><code>mysqld</code></pre><p><strong>效果演示</strong></p>
<p><img src="https://image.3001.net/images/20180503/15253126104329.png" alt></p>
<h2 id="获取通讯录列表"><a href="#获取通讯录列表" class="headerlink" title="获取通讯录列表"></a><a href="#获取通讯录列表" title="获取通讯录列表"></a>获取通讯录列表</h2><p><img src="https://image.3001.net/images/20180503/15253128744968.png" alt></p>
<h2 id="查看短信内容列表"><a href="#查看短信内容列表" class="headerlink" title="查看短信内容列表"></a><a href="#查看短信内容列表" title="查看短信内容列表"></a>查看短信内容列表</h2><p><img src="https://image.3001.net/images/20180503/15253131256045.png" alt></p>
<h2 id="发送短信"><a href="#发送短信" class="headerlink" title="发送短信"></a><a href="#发送短信" title="发送短信"></a>发送短信</h2><p>支持同时发送多个号码, 实现群发的效果, 官方介绍如下:</p>
<pre><code>mysql -uroot -p</code></pre><p><strong>发送测试</strong></p>
<p>Bash</p>
<pre><code>pkg install php</code></pre><p><img src="https://image.3001.net/images/20180503/15253135795603.png" alt></p>
<h2 id="拨打电话"><a href="#拨打电话" class="headerlink" title="拨打电话"></a><a href="#拨打电话" title="拨打电话"></a>拨打电话</h2><p>Bash</p>
<pre><code>&lt;?php phpinfo();?&gt;</code></pre><p>拨打电话给<code>10001</code>中国电信, 查看下话费有没有欠费~?</p>
<pre><code>php -S 127.0.0.1:8080 -t www/</code></pre><p><img src="https://image.3001.net/images/20180503/15253140551807.png" alt></p>
<h2 id="WiFi-相关"><a href="#WiFi-相关" class="headerlink" title="WiFi 相关"></a><a href="#WiFi相关" title="WiFi相关"></a>WiFi 相关</h2><p><strong>获取当前 WiFi 连接信息</strong></p>
<p>Bash</p>
<pre><code>pkg install nginx</code></pre><p><strong>获取最近一次 WiFi 扫描信息</strong></p>
<p><img src="https://image.3001.net/images/20180503/15253138725488.png" alt></p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a><a href="#小结-1" title="小结"></a>小结</h2><p>直接操作调动系统底层的话, 可以通过编程来实现自动定时短信发送, 语音播报等 DIY 空间无线</p>
<p>一些无聊有趣的版块, 如果你是一个正经讲究人, 可以跳过这个板块以节约你的阅读时间.</p>
<h2 id="nyancat-彩虹猫"><a href="#nyancat-彩虹猫" class="headerlink" title="nyancat 彩虹猫"></a><a href="#nyancat-彩虹猫" title="nyancat 彩虹猫"></a>nyancat 彩虹猫</h2><p><strong>彩虹貓</strong>（英语：<strong>Nyan Cat</strong>）是在 2011 年 4 月上传在 Youtube 的视频，并且迅速爆红于网络，並在 2011 年 YouTube 浏览量最高的视频中排名第五.</p>
<p>Bash</p>
<pre><code>termux-chroot</code></pre><p><img src="https://image.3001.net/images/20180503/15253150101146.png" alt></p>
<p>什么鬼<del>完全 Get 不到国外人的趣味点</del></p>
<h2 id="终端二维码"><a href="#终端二维码" class="headerlink" title="终端二维码"></a><a href="#终端二维码" title="终端二维码"></a>终端二维码</h2><p>Linux 命令行下的二维码, 主要核心是这个网址:<code>http://qrenco.de/</code></p>
<p>Bash</p>
<pre><code>nginx</code></pre><p><img src="https://image.3001.net/images/20180503/15253248656208.png" alt></p>
<p>如果你不嫌无聊的话还可以扫描这个二维码, 然后就打开我的博客了.</p>
<h2 id="终端地图"><a href="#终端地图" class="headerlink" title="终端地图"></a><a href="#终端地图" title="终端地图"></a>终端地图</h2><p>一个基于<code>nodejs</code>编写的命令行下的地图.</p>
<pre><code>netstat -an |grep 8080</code></pre><p>进入终端地图</p>
<p><img src="https://image.3001.net/images/20180503/15253279325608.png" alt></p>
<p><strong>操作方法</strong></p>
<ul>
<li>方向键 移动</li>
<li><code>a</code>和<code>z</code>键 放大缩小</li>
<li><code>q</code>键 退出</li>
</ul>
<p>终端下的地图! 讲究人~ 如果你足够无聊的话, 还可以尝试能不能在这个地图上找到自己所在的位置.</p>
<h2 id="安装-Linux"><a href="#安装-Linux" class="headerlink" title="安装 Linux"></a><a href="#安装Linux" title="安装Linux"></a>安装 Linux</h2><p>甚至还可以在<code>Termux</code>里面在安装其他的<code>Linux</code>发行版.</p>
<p>由于本文篇幅已经过长了, 这里不在叙述了, 感兴趣, 能折腾的自己去找一些资料. 下面列出目前网友们用<code>Termux</code>可以成功安装的发行版:</p>
<ul>
<li>Ubuntu</li>
<li>Arch</li>
<li>Fedora</li>
<li>Kali Nethunter</li>
</ul>
<p><strong>Ubuntu</strong></p>
<p><img src="https://image.3001.net/images/20180503/152531894937.png" alt></p>
<p><strong>Fedora</strong></p>
<p><img src="https://image.3001.net/images/20180503/15253195783545.png" alt></p>
<h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a><a href="#内网穿透" title="内网穿透"></a>内网穿透</h2><p>使用<code>ngrok</code>或者<code>frp</code>可以将<code>Termux</code>上面搭建的网站映射到外网上去,<code>手机建站</code>也不是不可能了.</p>
<h2 id="Python-Jupyter-Notebook"><a href="#Python-Jupyter-Notebook" class="headerlink" title="Python Jupyter Notebook"></a><a href="#Python-Jupyter-Notebook" title="Python Jupyter Notebook"></a>Python Jupyter Notebook</h2><p>Jupyter notebook（又称 IPython notebook），支持运行超过 40 种编程语言。Python 的一个强大的模块, 成功安装的话可以实现比<code>caddy</code>的效果, 支持<code>web</code>下的终端操作, 支持代码高亮运行. 由于这里需要安装大量文件, 加上用户需求比较少, 这一块感兴趣的话可以自己去探索.</p>
<p><img src="https://image.3001.net/images/20180503/15253189096532.png" alt></p>
<h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a><a href="#下载工具" title="下载工具"></a>下载工具</h2><ul>
<li>you-get</li>
</ul>
<p>是一款命令行工具，用来下载网页中的视频、音频、图片，支持众多网站，包含 41 家国内主流视频、音乐网站，如 网易云音乐、AB<br>站、百度贴吧、斗鱼、熊猫、爱奇艺、凤凰视频、酷狗音乐、乐视、荔枝 FM、秒拍、腾讯视频、优酷土豆、央视网、芒果 TV<br>等等，只需一个命令就能直接下载视频、音频以及图片回来，并且可以自动合并视频。而对于有弹幕的网站，比如 B 站，还可以将弹幕下载回来</p>
<ul>
<li>BaiduPCS-Go</li>
</ul>
<p>仿 Linux shell 文件处理命令的百度网盘命令行客户端.</p>
<p><a href="https://github.com/iikira/BaiduPCS-Go" target="_blank" rel="noopener">项目地址</a></p>
<p>可以完美在<code>Termux</code>上运行.</p>
<p><img src="https://image.3001.net/images/20180503/15253199952050.png" alt></p>
<p>相对来说 国外的 Termux DIY 的氛围比国内好很多, Youtube 上的视频都有很高的播放量:</p>
<p><img src="https://image.3001.net/images/20180503/1525326786911.png" alt></p>
<p>当然国内也有这么一批执着于<code>Termux</code>的玩家, 只是相对来说还比较小众, 写这篇文章只想让更多的人认识到<code>Termux</code>的生产力, 使用<code>Termux</code>来做一些很 cool 的事情. 期待有更多<code>Termux</code>的优秀文章出现<del>~</del></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2019/11/19/使用 Android 手机进行开发的尝试/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/default_background.jpg" alt="使用Android进行开发的尝试">
                
                <h1>使用Android进行开发的尝试</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年11月19日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.7k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 7 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/Termux/">Termux</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/Android/">Android</a> <a class="nexmoefont icon-tag-fill -link" href="/tags/Termux/">Termux</a>
            
        </div>
        <article>
            
            <!-- 原文地址 https://www.cnblogs.com/Rex/p/11444455.html -->

<p>使用 Android 手机查看和修改 Excel 文件、PowerPoint 文件并连接幻灯机进行演示等办公方式想必大家已经有所了解。今天介绍一下怎样使用 Android 进行软件开发。</p>
<h2 id="Termux"><a href="#Termux" class="headerlink" title="Termux"></a>Termux</h2><p>使用 Android 进行软件开发最重要的工具是命令行终端。<a href="https://github.com/termux/termux-app" target="_blank" rel="noopener">Termux</a> 就是其中功能最丰富、生态最好的命令行终端。</p>
<p>Termux 可以通过 F-Droid 直接下载 apk 文件进行安装，或从 Google Play Store 下载。</p>
<p><img src="https://img2018.cnblogs.com/blog/6245/201909/6245-20190902012916624-304679974.png" alt></p>
<p>Termux 附带包管理器，能够下载常见的 Linux 命令行工具，如 openssh, wget, curl, git, clang, ninja 等。</p>
<pre><code>pkg install openssh wget curl git clang ninja</code></pre><h2 id="Hacker’s-Keyboard"><a href="#Hacker’s-Keyboard" class="headerlink" title="Hacker’s Keyboard"></a>Hacker’s Keyboard</h2><p>有了命令行，就能输入命令了，但是好像输入法没有上下左右键、没有 Ctrl 键，输入命令很不方便。这个时候可以安装 <a href="https://github.com/klausw/hackerskeyboard" target="_blank" rel="noopener">Hacker’s Keyboard</a> 输入法。这个输入法包含 PC 键盘上的所有按键。</p>
<p><img src="https://img2018.cnblogs.com/blog/6245/201909/6245-20190902012620036-65434433.png" alt></p>
<p><img src="https://img2018.cnblogs.com/blog/6245/201909/6245-20190902012713367-586895995.png" alt></p>
<p>如果大家使用的手机正好是和笔者的 BlackBerry Key² 一样拥有实体键盘，可以通过修改~/.termux/termux.properties 文件，在 Termux 中增加缺少的符号。详细参考<a href="https://wiki.termux.com/wiki/Touch_Keyboard" target="_blank" rel="noopener">这里</a>。</p>
<pre><code>extra-keys = [ \
[&#39;~&#39;,&#39;`&#39;,&#39;$&#39;,&#39;%&#39;,&#39;^&#39;,&#39;&amp;&#39;,&#39;=&#39;,&#39;|&#39;,&#39;BACKSLASH&#39;], \
[&#39;ESC&#39;,&#39;&lt;&#39;,&#39;&gt;&#39;, &#39;{&#39;, &#39;}&#39;,&#39;HOME&#39;,&#39;UP&#39;,&#39;END&#39;,&#39;PGUP&#39;], \
[&#39;TAB&#39;,&#39;CTRL&#39;,&#39;ALT&#39;, &#39;[&#39;, &#39;]&#39;,&#39;LEFT&#39;,&#39;DOWN&#39;,&#39;RIGHT&#39;,&#39;PGDN&#39;]]</code></pre><h2 id="OpenSSH"><a href="#OpenSSH" class="headerlink" title="OpenSSH"></a>OpenSSH</h2><p>OpenSSH 是 Termux 中必装软件，安装之后可以启动 SSH 服务器，并通过 SSH 客户端如 PuTTY 远程控制手机，并能通过 SCP 客户端如 WinSCP 访问手机上的 Termux 内部数据和 SD 卡目录。还能从手机远程连接其他开启 SSH 服务器的设备。</p>
<p>安装之后，运行 sshd 即可。登录需要在~/.ssh/authorized_keys 中和通常的 Linux 一样配置公钥。</p>
<p>Termux 可以通过 <a href="https://wiki.termux.com/wiki/Termux:Widget" target="_blank" rel="noopener">Termux:Widget</a> 来将一些用户自定义的命令行操作变成 Android Widget 放在桌面上方便点击执行。sshd 应该是必备的条目。</p>
<h2 id="micro"><a href="#micro" class="headerlink" title="micro"></a>micro</h2><p>Termux 中自带的文本编辑器为 vi。如果你对 vim 和 emacs 不熟悉，<a href="https://github.com/zyedidia/micro" target="_blank" rel="noopener">micro</a> 是一个优良的命令行文本编辑器。安装方法如下：</p>
<pre><code>pkg install micro</code></pre><p><img src="https://img2018.cnblogs.com/blog/6245/201909/6245-20190902012744575-1365552476.png" alt></p>
<p>使用方法非常简单，手指点击即可将光标移动到指定位置，Ctrl+S 保存，Ctrl+Q 退出，Alt+G 显示常用命令，Ctrl+G 显示帮助。</p>
<p>需要注意的是，默认模式下是不会软换行的。另外就是输入’”([等字符会自动输入配对的符号。建议修改这些配置。修改地址为~/.config/micro/settings.json，可以修改下列对应行的内容：</p>
<pre><code>&quot;autoclose&quot;: false,
&quot;softwrap&quot;: true,</code></pre><p>此外，在 SSH 连接时 micro 默认无法复制粘贴，因为光标被 micro 占用。此时可以按住 Shift 键再进行复制粘贴，如在 PuTTY 中按住 Shift 键鼠标选择复制，按住 Shift 键鼠标右键粘贴。</p>
<h2 id="nnn"><a href="#nnn" class="headerlink" title="nnn"></a>nnn</h2><p><a href="https://github.com/jarun/nnn" target="_blank" rel="noopener">nnn</a> 是 Termux 上的命令行文件管理器，可用于进行快速文件夹跳转。</p>
<p>安装方式</p>
<pre><code>pkg install nnn</code></pre><p><img src="https://img2018.cnblogs.com/blog/6245/201909/6245-20190902012848481-907881188.png" alt></p>
<p>常见的操作包括上下箭头切换光标，左箭头进入上级文件夹，右箭头或回车进入当前光标所在文件夹或打开文件，Q 退出，Ctrl+G 退出并进入到当前文件夹。注意 Ctrl+G 的功能需要<a href="https://github.com/jarun/nnn/wiki/Basic-use-cases#configure-cd-on-quit" target="_blank" rel="noopener">配置</a>。需要在~/.bash_profile 中加入如下函数：</p>
<pre><code>n()
{
    export NNN_TMPFILE=${XDG_CONFIG_HOME:-$HOME/.config}/nnn/.lastd

    nnn &quot;$@&quot;

    if [ -f $NNN_TMPFILE ]; then
            . $NNN_TMPFILE
            rm -f $NNN_TMPFILE &gt; /dev/null
            pwd &gt;&amp;2
    fi
}</code></pre><h2 id="Termux-API"><a href="#Termux-API" class="headerlink" title="Termux:API"></a>Termux:API</h2><p><a href="https://wiki.termux.com/wiki/Termux:API" target="_blank" rel="noopener">Termux:API</a> 可以实现一些 Android 功能的自动化，但其中最重要的功能是在 PC 和 Android 设备之间进行剪贴板的同步。</p>
<p>安装方式：先下载 apk 安装之后再在 Termux 中运行</p>
<pre><code>pkg install termux-api</code></pre><p>通过 SSH 执行下面的命令可以在终端显示 Android 剪贴板的内容</p>
<pre><code>termux-clipboard-get</code></pre><p>通过 SSH 执行下面的命令可以将指定内容设置到 Android 剪贴板上</p>
<pre><code>termux-clipboard-set &lt;内容&gt;</code></pre><h2 id="clang"><a href="#clang" class="headerlink" title="clang"></a>clang</h2><p><a href="https://llvm.org/" target="_blank" rel="noopener">clang</a> 的使用方式和正常一样。Termux 不支持 gcc，一般都使用 clang 进行编译。需要注意的是 Termux 中的系统 libc++ 库不支持静态库，只支持动态库，标准 C 库为 Bionic。虽然使用跨平台编译器和 musl libc 也能编译出能够在 Termux 上运行的程序，但是存在一些<a href="https://github.com/xeffyr/termux-stuff/tree/master/musl-libc-packages" target="_blank" rel="noopener">问题</a>。Termux 不支持 glibc。</p>
<p>安装方式</p>
<pre><code>pkg install clang llvm lld</code></pre><h2 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h2><p><a href="https://www.mono-project.com/" target="_blank" rel="noopener">mono</a> 没有包支持。但是有社区版本，如笔者编译的 <a href="https://github.com/IanusInferus/termux-mono" target="_blank" rel="noopener">termux-mono</a> 以及一些在 PRoot 运行的 Arch Linux 和 Ubuntu 中运行的版本。以下为 termux-mono 最新版本，不需要 PRoot 即可直接运行。</p>
<p><img src="https://img2018.cnblogs.com/blog/6245/201909/6245-20190902012811155-2016948412.png" alt></p>
<h2 id="Android-App-开发"><a href="#Android-App-开发" class="headerlink" title="Android App 开发"></a>Android App 开发</h2><p>虽然 Termux 中没有 JDK, Android SDK 和 Android NDK，但是仍然可以进行 Android App 开发。其中 JDK 可以使用 ecj 代替，Android SDK 可以使用独立的 dx, aapt 和 apksigner 代替，Android NDK 可以使用 clang 代替。使用这些软件通过调用命令行就能生成. so 文件, .dex 文件和. apk 文件。</p>
<p>安装方式</p>
<pre><code>pkg install ecj dx aapt apksigner</code></pre><p>需要注意的是，Android SDK API 28 引入的 d8 现在还<a href="https://github.com/termux/termux-packages/tree/master/disabled-packages/d8" target="_blank" rel="noopener">不支持</a>，所以编译 Java 8 和之后版本的代码会比较困难。</p>
<h2 id="Wcode"><a href="#Wcode" class="headerlink" title="Wcode"></a>Wcode</h2><p>Termux 内部查看和编辑代码不方便；Termux 中的文件无法被外部的 App 所查看和编辑；SDCard 模拟分区通常是 FAT32 格式的不支持执行权限，代码放在其中非常不方便。</p>
<p>于是有人想到通过在 Termux 中运行一个服务器，然后在外部连接服务器进行文件编辑的<a href="https://medium.com/samsung-internet-dev/writing-software-using-a-phone-e71976f1f18d" target="_blank" rel="noopener">方法</a>。为了实现类似于 Visual Studio Code 的编辑体验，他直接使用了 Visual Studio Code 的 <a href="https://github.com/microsoft/monaco-editor" target="_blank" rel="noopener">Monaco Editor</a>，在 Termux 中通过 nodejs 运行一个 HTTP 服务器，并在浏览器中进行访问。他的代码在<a href="https://github.com/SamsungInternet/web-code" target="_blank" rel="noopener">这里</a>。但是效果比较差，只适合在平板上运行。</p>
<p>后面又有人又做了一个类似的程序，就是 <a href="https://github.com/fmsouza/wcode" target="_blank" rel="noopener">Wcode</a>。</p>
<p>安装方式</p>
<pre><code>pkg install nodejs
npm install -g wcode</code></pre><p>笔者对 Wcode 进行了一些<a href="https://github.com/IanusInferus/wcode" target="_blank" rel="noopener">修改</a>，修正了一些 bug，并使其在手机上能更好地运行。</p>
<p><img src="https://img2018.cnblogs.com/blog/6245/201909/6245-20190902012949260-326794379.png" alt></p>
<p><img src="https://img2018.cnblogs.com/blog/6245/201909/6245-20190902013009832-359372059.png" alt></p>
<h2 id="快捷输入"><a href="#快捷输入" class="headerlink" title="快捷输入"></a>快捷输入</h2><p>很多常用命令很长，输入不变，可以通过 bash alias 来进行简记。</p>
<p>打开~/.bash_profile，即可增加 alias 指令。笔者的 alias 指令如下：</p>
<pre><code>alias cg=termux-clipboard-get
alias cs=termux-clipboard-set
alias m=micro
alias i=&#39;ifconfig | grep &#39;\&#39;&#39;inet &#39;\&#39;&#39; | sed &#39;\&#39;&#39;s/ *inet//g&#39;\&#39;&#39; | cut -d&#39;\&#39;&#39; &#39;\&#39;&#39; -f2&#39;
alias p=&#39;ping www.bing.com&#39;
alias w=wcode</code></pre><p>其中 i 为显示当前 IP 地址。</p>
<p>之后退出 Termux 再进入，即可通过简短命令来运行程序了。</p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2019/11/19/七大经典排序算法/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/default_background.jpg" alt="七大经典排序算法">
                
                <h1>七大经典排序算法</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年11月19日</a>
            <a><i class="nexmoefont icon-areachart"></i>4.1k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 20 分钟</a>
            
                <a class="nexmoefont icon-appstore-fill -link" href="/categories/Algorithm/">Algorithm</a><a class="nexmoefont icon-appstore-fill -link" href="/categories/Algorithm/算法/">算法</a>
            
            
                <a class="nexmoefont icon-tag-fill -link" href="/tags/排序/">排序</a> <a class="nexmoefont icon-tag-fill -link" href="/tags/算法/">算法</a>
            
        </div>
        <article>
            
            <!-- 原文地址 https://blog.csdn.net/weixin_43224539/article/details/88978013 -->

<p>常见排序算法可以分为两大类：<br><strong>非线性时间比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 O(nlogn)，因此称为非线性时间比较类排序。<br><strong>线性时间非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。<br><img src="https://img-blog.csdn.net/20180924222317326?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JvY2xpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>   </p>
<p>算法复杂度 </p>
<p> <img src="https://img-blog.csdn.net/20180924222317358?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JvY2xpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<h3 id="1-冒泡排序-BubbleSort"><a href="#1-冒泡排序-BubbleSort" class="headerlink" title="1. 冒泡排序 (BubbleSort)"></a>1. 冒泡排序 (BubbleSort)</h3><p>冒泡排序是一种简单的排序算法，是一种<strong>减治算法</strong>的应用, 通过重复走过要排序的数组，每一次比较两个<strong>相邻</strong>元素的大小，如果后一个元素比前一个元素小就交换过来，最终完成排序，这种算法的命名也是由最小的元素总是会慢慢从最后 “浮” 到前面来而得名 (每次从无序区间取一个数去无序区间遍历)</p>
<p><strong>步骤：</strong></p>
<ul>
<li>从第一组两个相邻元素开始比较，依次往后交换</li>
<li>每经过一次排序较大的元素就会被放到后面，直到最大的元素被放到最后，那么下一次排序的时候也就不用用它（最后一个数）和它相邻的前面的数进行比较了，最后的元素就成了 “稳定元素”</li>
<li>重复以上步骤，每一次排序完成，最后的 “稳定元素” 都会增加一个，直到没有可以交换的元素，那么排序就完成了</li>
</ul>
<p>** 动态图演示：**</p>
<p><img src="https://img-blog.csdnimg.cn/20190402182841860.gif" alt></p>
<p>** 代码展示**</p>
<pre><code>package com;

import java.util.Arrays;

/**
 * package:com
 * Description:bubbleSort
 * @date:2019/4/27
 * @Author:weiwei
 **/
public class bubbleSort {
    /**
     * 双层循环遍历数组
     * 第一层循环表示循环次数,一次循环解决一个数的问题,一共需要array.length次
     *       更优化的方式是array.length-1次(最后一个数不需要比较)
     * 第二层比较相邻两个数的大小,共需要array.length-2-i次(i是循环到哪个数,2是最后一个数不用比较
     *       下标从 0 开始,所以是减二
     * @param array
     * @return
     */
    private static int[] bubbleSort(int [] array){
        for(int i = 0;i&lt;array.length;i++){
            for(int j = 0;j &lt;= array.length -2-i;j++){

                if(array[j] &gt; array[j+1]){
                    int temp = array[j];
                    array[j] = array[j+1];
                    array[j+1] = temp;
                }
            }
        }
        return array;
    }
    public static void main(String[] args) {
        int[] array = {9,2,4,7,5,8,1,3,6};
        System.out.println(Arrays.toString(bubbleSort(array)));

    }
}</code></pre><h3 id="2-选择排序-SelectionSort"><a href="#2-选择排序-SelectionSort" class="headerlink" title="2. 选择排序 (SelectionSort)"></a>2. 选择排序 (SelectionSort)</h3><p>选择排序是一种简单直观的排序算法, 是<strong>减治算法</strong>的应用, 对数据不敏感, 原理是:</p>
<p>   首先在未排序序列中找到最小元素, 存放到排列序列的起始位置, 然后在剩余未排序元素中继续寻找最小元素, 然后放到已经排好序序列的末尾, 以此类推, 直到所有元素均排序完毕</p>
<p>步骤:</p>
<ul>
<li>把要排序的序列分为有序序列和无序序列</li>
<li>遍历序列, 每一次从无序序列找到最小元素, 定义为 minIndex=i, 放到无序序列最前面,</li>
<li>直到无序区间内没有元素, 也就是所有元素都排好序</li>
</ul>
<p>动图演示:</p>
<p><img src="https://img-blog.csdnimg.cn/20190406212711758.gif" alt></p>
<p>代码展示: </p>
<pre><code>package Sort;

import java.util.Arrays;

/**
 * Author:weiwei
 * description:
 * Creat:2019/5/2
 **/
public class SelectSort {

    private static int[] SelectSort(int[] array) {
        for (int i = 0; i &lt; array.length; i++) {
            int min = i;
            for (int j = i+1; j &lt; array.length; j++) {
                if (array[j] &lt; array[min]) {
                    min = j;
                }
            }
            int t = array[min];
            array[min] = array[i];
            array[i] = t;

        }
        return array;
    }

    public static void main(String[] args) {
        int[] array = {8,3,7,1,4,6,2,9,5};
        System.out.println(Arrays.toString(SelectSort(array)));
    }
}</code></pre><h3 id="3-插入排序-Insertion-Sort"><a href="#3-插入排序-Insertion-Sort" class="headerlink" title="3. 插入排序 (Insertion Sort)"></a>3. 插入排序 (Insertion Sort)</h3><p>插入排序是一种简单直观的排序算法, 是<strong>减治算法</strong>的应用, 原理是: 通过构建有序数列, 对于未排序数据, 在已排序序列中, 从后往前扫描, 找到对应位置并插入 (每次从无序区间取一个数到有序区间去遍历, 找到插入的位置)</p>
<p>步骤:</p>
<ul>
<li>从第一个元素开始, 认为第一个元素已经被排序</li>
<li>取出下一个元素, 在已排好序的序列中从后往前扫描</li>
<li>如果该元素 (已排好序) 大于新元素, 将该元素移到下一位置</li>
<li>重复步骤 3, 直到找到已排好序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤 2-5</li>
</ul>
<p>动图演示:</p>
<p><img src="https://img-blog.csdnimg.cn/20190406215559907.gif" alt></p>
<p>代码展示:</p>
<pre><code>package Sort;

import java.util.Arrays;

/**
 * Author:weiwei
 * description:
 * Creat:2019/5/3
 **/
public class insertSort {

    /**遍历查找
     *先查找
     *再搬
     * @param array
     */
    private static void insertSort1(int[] array){
        for(int i =0;i&lt;array.length;i++){
            //有序[0,i)
            //无序[i,array.length)
            //1.在有序区间遍历查找,从后往前查找
            int j;
            for(j=i-1;j &gt;= 0 &amp;&amp;array[i] &lt; array[j];j--){
            }
            //j+1就是要插入的位置
            //插入数据,从后往前搬数据
            int pos = j+1;
            int key = array[i];
            for( int k = i;k&gt;pos;k--){
                array[k] = array[k-1];
            }
            array[pos] = key;
        }
    }

    /**遍历查找
     * 边查找边搬
     * @param array
     */
    private static int[] insertSort2(int[] array){
        int len = array.length;
        int preIndex,current;
        for(int i = 0;i&lt;len;i++){
            preIndex = i-1;
            current = array[i];

            while(preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; current ){
                array[preIndex+1] = array[preIndex];
                preIndex--;
            }
            array[preIndex+1] = current;
        }
        return array;
    }

    /**
     * 二分查找(重点)
     * @param array
     */
    private static void insertSort3(int[] array){
        for(int i = 0;i&lt;array.length;i++){
            int key = array[i];
            //[0,i)
            int left = 0;
            int right = i;

            while(left &lt; right){
                int mid = left + (left - right)/2;
                if(key == array[mid]){
                    left = mid + 1;
                }else if(key &lt; array[mid]){
                    right = mid;
                }else{
                    left = mid +1;
                }
            }
            int pos = left;
            for (int k = i;k&gt;pos;k--){
                array[k] = array[k-1];
            }
            array[pos] = key;
        }
    }

    public static void main(String[] args) {
        int[] array = {9,2,7,4,5,3,1,8,6,5};
        insertSort1(array);
        System.out.println(Arrays.toString(array));
    }
}</code></pre><h3 id="4-希尔排序（shell-sort）"><a href="#4-希尔排序（shell-sort）" class="headerlink" title="4. 希尔排序（shell sort）"></a>4. 希尔排序（shell sort）</h3><p>希尔排序是第一个突破 O(n^2) 的排序算法，是简单插入排序的改进法， 它与插入排序不同之处在于，它会提前做一个预排序, 给序列分组预排序, 也叫做<strong>分组插排</strong>, 分的组越多越接近有序</p>
<p>动图演示：</p>
<pre><code>                ![](https://img-blog.csdnimg.cn/2019041519563662.gif)</code></pre><p>代码展示：</p>
<pre><code>package Sort;

import java.util.Arrays;

/**
 * Author:weiwei
 * description:希尔排序
 * Creat:2019/5/3
 **/
public class insertSortWithGap {

    private static void insertSortWithGap(int[] array, int gap) {
        for (int i = 0; i &lt; array.length; i++) {
            int key = array[i];
            int j = i - gap;
            for (; j &gt;= 0 &amp;&amp; key &lt; array[j]; j = j - gap) {
                array[j + gap] = array[j];
            }
            array[j + gap] = key;
        }
    }

    /**
     * 时间复杂度:
     * 最好情况:O(n)
     * 最坏情况:O(n^2)   比插排最坏情况的概率变小了
     * 平均情况:O(n^1.2 - 1.3)
     * 空间复杂度:O(1)
     * 稳定性:不稳定
     *
     * @param array
     */
    private static int[] shellSort(int[] array) {
        int gap = array.length;
        while (true) {
            //gap = gap /2;
            gap = (gap / 3) + 1;

            insertSortWithGap(array, gap);

            if (gap == 1) {
                break;
            }
        }
        return array;
    }

    public static void main(String[] args) {
        int [] array = {9,3,1,4,7,2,8,6,5};
        System.out.println(Arrays.toString(shellSort(array)));
    }
}</code></pre><h3 id="5-归并排序（Merge-sort）"><a href="#5-归并排序（Merge-sort）" class="headerlink" title="5. 归并排序（Merge sort）"></a>5. 归并排序（Merge sort）</h3><p>归并排序是建立在一种建立在归并算法上一种有效的排序方法，该方法是采用<strong>分治算法</strong>的一个典型的应用，对数据不敏感, 将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列间有序，算法复杂度为 (nlogn)</p>
<p>算法描述：</p>
<ol>
<li><p>把长度为 n 的序列分为两个长度为 n/2 的子序列</p>
</li>
<li><p>对这两个子序列分别归并排序</p>
</li>
<li><p>将两个排序好的子序列合并成一个最终的有序序列</p>
</li>
</ol>
<p>动图演示：</p>
<p><img src="https://img-blog.csdnimg.cn/20190415201449551.gif" alt></p>
<p>代码展示：</p>
<pre><code>package Sort;

import java.util.Arrays;

/**
 * Author:weiwei
 * description:归并排序(递归方式)
 * Creat:2019/4/27
 **/
public class MergeSort {
    private static void merge(int[] array,int low,int mid,int high,int[] extra){
        int i = low;  //遍历[low,mid]
        int j = mid;  //遍历[mid,high]
        int x = 0;    //遍历extra

        while(i &lt; mid &amp;&amp; j &lt; high){
             if(array[i] &lt;= array[j]){
                 extra[x++] = array[i++];
             }else{
                 extra[x++] = array[j++];
             }
        }
        while(i &lt; mid){
            extra[x++] = array[i++];
        }
        while(j &lt; high){
            extra[x++] = array[j++];
        }
        for(int k = low;k &lt; high;k++){
            array[k] = extra[k - low];
        }
    }
    private static void mergeSortInner(int[] array,int low,int high,int[] extra){
        if (low == high - 1){
            return;
        }
        if(low &gt;= high){
            return;
        }

        //平均切分
        int mid = low + (high - low)/2;
        //[low,mid)+[mid,high)
        //2.分治算法处理两个小区间
        mergeSortInner(array,low,mid,extra);
        mergeSortInner(array,mid,high,extra);

        //左右两个小区间已经有序了
        merge(array,low,mid,high,extra);
    }

    private static void mergeSort(int[] array) {
        int[] extra = new int [array.length];//设定长度,避免造成空间浪费
        mergeSortInner(array,0,array.length,extra);
    }

    //非递归方式
    private static void mergeNoR(int[] array){
        int[] extra = new int [array.length];
        for(int i = 1;i&lt;array.length;i *= 2){
            for(int j =0;j&lt;array.length;j +=2 * i){
                int low = j;
                int mid = low + i;
                if( mid &gt;= array.length){
                    continue;
                }
                int high = mid + i;
                if(high &gt; array.length){
                    high = array.length;
                }
                merge(array,low,mid,high,extra);
            }
        }
    }

    public static void main(String[] args) {
        int[] array1 = {9,3,1,5,4,2,7,6,8};
        int[] array2 = {8,3,1,2,5,3,7,6,2};
        mergeSort(array1);
        mergeNoR(array2);
        System.out.println(Arrays.toString(array1));
        System.out.println(Arrays.toString(array2));
    }
}</code></pre><h3 id="6-快速排序-Quick-Sort"><a href="#6-快速排序-Quick-Sort" class="headerlink" title="6. 快速排序 (Quick Sort)"></a>6. 快速排序 (Quick Sort)</h3><p>  快速排序的基本思想：</p>
<pre><code>    在要排序的序列中选择一个基准值 (通常选择最右边的值为基准值), 然后遍历整个序列, 每个数都和基准值进行比较, 并且发生一定的交换, 遍历结束后使得比基准值小的数(包括等于) 都在基准值的左边, 比基准值大的数 (包括等于) 都在基准值的右边, 然后采用分治算法的思想, 分别对两个小的区间进行同样的方式处理, 直到区间的 size=0 或者 = 1, 就说明序列已经有序了, 快速排序完成</code></pre><p>算法描述:</p>
<p>快速排序使用<strong>分治算法</strong>来把一个序列分为两个子序列, 具体算法描述如下：</p>
<ol>
<li><p>从序列中选择最右边的数作为基准, 称为 “基准值”（<strong>pivot</strong>）；</p>
<p><img src="https://img-blog.csdnimg.cn/20190504163305330.png" alt>  </p>
</li>
<li><p>遍历排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一               边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（<strong>partition</strong>）操作；</p>
<pre><code> ![](https://img-blog.csdnimg.cn/2019050416332747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzIyNDUzOQ==,size_16,color_FFFFFF,t_70)  </code></pre></li>
<li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
</li>
</ol>
<p>快速排序的步骤:</p>
<ol>
<li>选择基准值 (选择基准值有三个方法)</li>
</ol>
<ul>
<li>选择最边上作为基准值 (左右都可以)</li>
<li>随机法 (random.nextInt())</li>
<li>三数取中法 [对于第二三中方法, 确定基准值后, 将基准值交换到最边上]      </li>
</ul>
<ol start="2">
<li>分割 (partition 操作), 比基准值 &lt;= 在基准值左边, 比基准值 &gt;= 在基准值右边, partition 操作也有三种方法:</li>
</ol>
<ul>
<li>Hover 法 (左右遍历)</li>
<li>挖坑法 (左右遍历)</li>
<li>前后下标法 (前后遍历)</li>
</ul>
<ol start="3">
<li>用分治法处理左右两个小区间, 直到区间的 size == 1(已经有序) 或者 size == 0, 则停止排序 动态图展示: </li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20190415211841667.gif" alt></p>
<p>代码展示:</p>
<p>快速排序</p>
<pre><code>package Sort;

import java.util.Arrays;

/**
 * Author:weiwei
 * description:快速排序
 * Creat:2019/4/27
 **/
public class QuickSort {

    private static void swap(int[] array,int i,int j){
        int t = array[i];
        array[i] = array[j];
        array[j] = t;
    }

    private static int  partition1(int[] array,int left,int right){
        int begin = left;
        int end = right;
        int pivot = array[right];
        while(begin &lt; end){
            while( begin &lt; end &amp;&amp; array[begin] &lt;= pivot){
                begin++;  //当前数比基准值小,就往后遍历,遇到比基准值大的数才停下来
            }
            while(begin &lt; end &amp;&amp; array[end] &gt;= pivot){
                end--;    //当前数比基准值大,就往前遍历,遇到比基准值小的数才停下来
            }
            swap(array,begin,end); //否则,遍历无法继续,交换所指向的值,再继续遍历
        }
        swap(array,begin,right);  //遍历到最后begin == end,将right的值与begin的值交换
        return begin;             //此时,序列中基准值左边所有的值就比基准值小,右边的数就比基准值大

    }
private static void quickSortInner(int[] array,int left,int right){
        if(left &gt; right){
            //size == 1 已经有序
            return;
        }
        if(left == right){
            //size == 0
            return;
        }
        int originIndex = medianofthree(array,left,right);
        swap(array,originIndex,right);

        //要排序的区间是array[left,right]
        //1.找基准值 array[right]
        //2.遍历整个区间,把区间的为三部分
        int pivotIndex = partition1(array,left,right);
        //3.分治算法
        //用相同的方式处理两个小区间,直到size == 1 | size == 0
        //比基准值小的区间[left,pivotIndex-1]
        quickSortInner(array,left,pivotIndex-1);
        //比基准值大的区间[pivotIndex+1,right]
        quickSortInner(array,pivotIndex+1,right);
    }
    private static void  quickSort(int[] array){
        quickSortInner(array,0,array.length -1);
    }

    public static void main(String[] args) {
        int[] array = {9,3,1,5,4,2,7,6,8};
        quickSort(array);
        System.out.println(Arrays.toString(array));
    }
}</code></pre><p> 用 Hover 方法进行 partition 操作</p>
<pre><code>//Hover法做partition操作
    private static int  partition1(int[] array,int left,int right){
        int begin = left;
        int end = right;
        int pivot = array[right];
        while(begin &lt; end){
            while( begin &lt; end &amp;&amp; array[begin] &lt;= pivot){
                begin++;  //当前数比基准值小,就往后遍历,遇到比基准值大的数才停下来
            }
            while(begin &lt; end &amp;&amp; array[end] &gt;= pivot){
                end--;    //当前数比基准值大,就往前遍历,遇到比基准值小的数才停下来
            }
            swap(array,begin,end); //否则,遍历无法继续,交换所指向的值,再继续遍历
        }
        swap(array,begin,right);  //遍历到最后begin == end,将right的值与begin的值交换
        return begin;             //此时,序列中基准值左边所有的值就比基准值小,右边的数就比基准值大

    }</code></pre><p>用挖坑法做 partition 操作</p>
<pre><code>//用挖坑法做partition操作
    private static int partition2(int[] array,int left,int right){
        int begin = left;
        int end = right;
        int pivot = array[right];
        while(begin &lt; end){
            while(begin &lt; end &amp;&amp; array[begin] &lt;= pivot){
                begin++;   //当前数比基准值小,就往后遍历,遇到比基准值大的数才停下来
            }
            array[begin] = array[end];  //否则,将end的值赋给begin
            while(begin &lt; end &amp;&amp; array[begin] &lt;= pivot){
                end--;    //当前数比基准值大,就往前遍历,遇到比基准值小的数才停下来
            }
            array[end] = array[begin]; //否则,将begin的值赋给end
        }
        array[begin] = pivot;  //最终begin == end时,将pivot的值赋给begin
        return begin;
    }</code></pre><p> 用前后遍历的方法 partition 操作</p>
<pre><code>//前后下标法做partition操作
    private static int parttiton3(int[] array,int left,int right){
        int d = left;
        for(int i = left;i&lt;right;i++){
            if(array[i] &lt; array[right]){
                swap(array,d,i);
                d++;
            }
        }
        swap(array,d,right);
        return d;
    }</code></pre><p>选择基准的方法: 三数取中法</p>
<pre><code>//三数取中
    private static int medianofthree(int[] array,int left,int right) {
        int mid = left + (right - left) / 2;
        if (array[left] &gt; array[right]) {
            if (array[left] &lt; array[mid]) {
                return left;
            } else if (array[mid] &gt; array[right]) {
                return mid;
            } else {
                return right;
            }
        } else {
            if (array[right] &lt; array[mid]) {
                return right;
            } else if (array[mid] &gt; array[left]) {
                return mid;
            } else {
                return left;
            }
        }
    }</code></pre><h3 id="7-堆排序-Heap-Sort"><a href="#7-堆排序-Heap-Sort" class="headerlink" title="7. 堆排序 (Heap Sort)"></a>7. 堆排序 (Heap Sort)</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。是<strong>减治算法</strong>的应用, 对数据不敏感, 堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p> 算法描述</p>
<pre><code> 1. 将初始待排序关键字序列构建成大堆，此堆为初始的无序区；  
 2. 选择最大的元素 (堆顶元素) 放到无序序列最后面，此时得到新的无序区和新的有序区, 每次在无序序列中选择最大的的元素放到无序序列最后面,  
 3. 直到最后叶子结点, 不再向下调整, 堆排序完成  </code></pre><p>动态图演示:</p>
<pre><code>                                  ![](https://img-blog.csdnimg.cn/20190421095934922.gif)</code></pre><p>代码展示:</p>
<pre><code>package com.bittech;

/**
 * Author:weiwei
 * description:堆排序
 * Creat:2019/4/27
 **/
public class heapSort {

    private static void heapify(int[] array,int size,int index){
        //判断index是不是叶子结点
        while(2*index+1 &lt; size){
            //找到最大孩子的下标
            int max = 2 * index + 1;
            if(max + 1 &lt;size &amp;&amp; array[max+1] &gt; array[max]){
                max = 2 * index + 2;
            }

            //3.判断最大得孩子和根的值
            if(array[index] &lt; array[max]){
                swap(array,index,max);

                index = max;
            }else{
                //根的值比较大,不需要交换,可以直接退出了
                break;
            }
        }
    }
    private static void createHeap(int[] array){
        //[从最后一个非叶子节点的下标,根]  向下调整
        //[(array.length-2)/2,0]
        for(int i = (array.length-2/2);i&gt;=0;i--){
            heapify(array,array.length,i);
        }
    }
    private static void swap(int[] array,int i,int j){
        int t =array[i];
        array[i] = array[j];
        array[j] = t;

    }
    private static void heapSort(int[] array){
        //建堆  大堆
        createHeap(array);

        //减治处理
        for(int i =0;i&lt;array.length;i++){
            //有序[length - i,length]
            //无序[0,length - i - 1]
            //最大的数在[0],最大的数应该放到的下标是
            //[length-i-1]
            swap(array,0,array.length -1-i);
            //处理[0]无序剩余部分满足堆的性质
            //无序[0,length-i-2]
            //有序[length-i-1,length]
            //size剩余无序部分的长度
            heapify(array,array.length-1-i,0);
        }
    }

    public static void main(String[] args) {
        int[] array = { 9, 5, 2, 7, 3, 6, 8, 8, 4, 9, 3, 1, 2 };
        heapSort(array);
        for (int item: array) {
            System.out.print(item + &quot; &quot;);
        }
        System.out.println();
    }
}</code></pre>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2019/06/27/Sematic Web and Knowledge Graph/">
            <div class="nexmoe-post-cover mdui-ripple"> 
                
                    <img src="/images/default_background.jpg" alt="Sematic Web &amp; Knowledge Graph">
                
                <h1>Sematic Web &amp; Knowledge Graph</h1>
            </div>
        </a>
        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年06月27日</a>
            <a><i class="nexmoefont icon-areachart"></i>283 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
            
            
        </div>
        <article>
            
            <h1 id="Sematic-Web-amp-Knowledge-Graph"><a href="#Sematic-Web-amp-Knowledge-Graph" class="headerlink" title="Sematic Web &amp; Knowledge Graph"></a>Sematic Web &amp; Knowledge Graph</h1><p>By Prof. Christophe Roche; KETRC, LCU; 14th Nov. ,2019</p>
<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul>
<li>Society of Information &amp; Knowledge Graph</li>
<li>Building KG<ul>
<li>Resource Description Framework</li>
<li>Definitions</li>
<li>Vocabularies</li>
</ul>
</li>
<li>Querying KG<ul>
<li>SPARQL</li>
</ul>
</li>
<li>Exercises</li>
</ul>
<h3 id="Def-of…"><a href="#Def-of…" class="headerlink" title="Def of…"></a>Def of…</h3><h4 id="IoT"><a href="#IoT" class="headerlink" title="IoT:"></a>IoT:</h4><p>Digital devices &amp; objects that connect automatically without human-human interaction.</p>
<h4 id="KG"><a href="#KG" class="headerlink" title="KG:"></a>KG:</h4><p>Knowledge in a machine readable form</p>
<h4 id="RDF-Resource-Description-Framework-资源描述框架"><a href="#RDF-Resource-Description-Framework-资源描述框架" class="headerlink" title="RDF Resource Description Framework 资源描述框架"></a>RDF Resource Description Framework 资源描述框架</h4><p>什么是什么</p>
<h4 id="RDFS-资源描述框架定义集"><a href="#RDFS-资源描述框架定义集" class="headerlink" title="RDFS 资源描述框架定义集"></a>RDFS 资源描述框架定义集</h4><h4 id="Differences-between-RDF-amp-RDFS"><a href="#Differences-between-RDF-amp-RDFS" class="headerlink" title="Differences between RDF &amp; RDFS"></a>Differences between RDF &amp; RDFS</h4><p>RDF - Properties - 属性</p>
<p>RDFS - Domain &amp; range - 领域和范围</p>
<h4 id="FOAF-Friend-of-a-friend"><a href="#FOAF-Friend-of-a-friend" class="headerlink" title="FOAF  Friend of a friend"></a>FOAF  Friend of a friend</h4><p>​     a machine-readable ontology describing persons, their activities and their relations to other people and objects. Anyone can use FOAF to describe themself. FOAF allows groups of people to describe social networks without the need for a centralised database.</p>
<h4 id="SKOS-简单知识组织系统-Simple-Knowledge-Organization-System"><a href="#SKOS-简单知识组织系统-Simple-Knowledge-Organization-System" class="headerlink" title="SKOS 简单知识组织系统 Simple Knowledge Organization System"></a>SKOS 简单知识组织系统 Simple Knowledge Organization System</h4><p>URL Universal Resources Location</p>
<p>URI Universal Resources Identifier 统一资源标识符</p>
<p>URN Universal Res. Name</p>
<p>IRI Internationalized …</p>
<p>字典 - 本体 - 术语</p>
<p>EDM :Entity Data Model 实体数据模型</p>
<p>前加问号代表一个变量</p>
<h3 id="Example-looking-for-representations-of-Mozart-in-France-National-Lib"><a href="#Example-looking-for-representations-of-Mozart-in-France-National-Lib" class="headerlink" title="Example: looking for representations of Mozart in France National Lib"></a>Example: looking for representations of Mozart in France National Lib</h3><ul>
<li><p>Looking for resources which are humans</p>
</li>
<li><p>?x is-a Person</p>
</li>
</ul>
<h3 id="Query-Patterns"><a href="#Query-Patterns" class="headerlink" title="Query Patterns"></a>Query Patterns</h3><p>ontoterminology - Ontology and Terminology</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>PREFIX foaf: <a href="http://xmlns.com/foaf/0.1/" target="_blank" rel="noopener">http://xmlns.com/foaf/0.1/</a><br>PREFIX owl: <a href="http://www.w3.org/2002/07/owl#" target="_blank" rel="noopener">http://www.w3.org/2002/07/owl#</a><br>PREFIX rdfs: <a href="http://www.w3.org/2000/01/rdf-schema#" target="_blank" rel="noopener">http://www.w3.org/2000/01/rdf-schema#</a><br>PREFIX owl: <a href="http://www.w3.org/2002/07/owl#" target="_blank" rel="noopener">http://www.w3.org/2002/07/owl#</a><br>PREFIX bibo: <a href="http://purl.org/ontology/bibo/" target="_blank" rel="noopener">http://purl.org/ontology/bibo/</a><br>PREFIX dc: <a href="http://purl.org/dc/elements/1.1/" target="_blank" rel="noopener">http://purl.org/dc/elements/1.1/</a><br>PREFIX dcterms: <a href="http://purl.org/dc/terms/" target="_blank" rel="noopener">http://purl.org/dc/terms/</a></p>

            
        </article>
    </div>
    
</section>

    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/mdui@0.4.3/dist/js/mdui.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
 
    <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>


 
    <script src="https://cdn.jsdelivr.net/npm/smoothscroll-for-websites@1.4.9/SmoothScroll.min.js"></script>


<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="/js/app.js?v=1574932694068"></script>
<script src="https://cdn.jsdelivr.net/npm/lazysizes@5.1.0/lazysizes.min.js"></script>


    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>



  





    <!-- baidu Analytics -->
<script>
    var _hmt = _hmt || [];
    (function() {var hm = document.createElement('script');
    hm.src = 'https://hm.baidu.com/hm.js?3a0193fa24ece2ff69380ae21ae95075';
    var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

</body>

</html>
